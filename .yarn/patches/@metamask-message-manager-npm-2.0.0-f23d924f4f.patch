diff --git a/dist/AbstractMessageManager.d.ts b/dist/AbstractMessageManager.d.ts
index 5c880250d56006d0889ca008f734854d47504f71..8495c191e1af58175ef7aaca7017fbabe452ef70 100644
--- a/dist/AbstractMessageManager.d.ts
+++ b/dist/AbstractMessageManager.d.ts
@@ -1,6 +1,7 @@
 /// <reference types="node" />
 import { EventEmitter } from 'events';
 import { BaseController, BaseConfig, BaseState } from '@metamask/base-controller';
+import { Json } from '@metamask/controller-utils';
 /**
  * @type OriginalRequest
  *
@@ -18,6 +19,7 @@ export interface OriginalRequest {
  * @property type - The json-prc signing method for which a signature request has been made.
  * A 'Message' which always has a signing type
  * @property rawSig - Raw data of the signature request
+ * @property securityProviderResponse - Response from a security provider, whether it is malicious or not
  */
 export interface AbstractMessage {
     id: string;
@@ -25,12 +27,13 @@ export interface AbstractMessage {
     status: string;
     type: string;
     rawSig?: string;
+    securityProviderResponse?: Map<string, Json>;
 }
 /**
  * @type MessageParams
  *
  * Represents the parameters to pass to the signing method once the signature request is approved.
- * @property from - Address to sign this message from
+ * @property from - Address from which the message is processed
  * @property origin? - Added for request origin identification
  */
 export interface AbstractMessageParams {
@@ -43,7 +46,7 @@ export interface AbstractMessageParams {
  * Represents the parameters to pass to the signing method once the signature request is approved
  * plus data added by MetaMask.
  * @property metamaskId - Added for tracking and identification within MetaMask
- * @property from - Address to sign this message from
+ * @property from - Address from which the message is processed
  * @property origin? - Added for request origin identification
  */
 export interface AbstractMessageParamsMetamask extends AbstractMessageParams {
@@ -62,11 +65,17 @@ export interface MessageManagerState<M extends AbstractMessage> extends BaseStat
     };
     unapprovedMessagesCount: number;
 }
+/**
+ * A function for verifying a message, whether it is malicious or not
+ */
+export declare type SecurityProviderRequest = (requestData: AbstractMessage, messageType: string) => Promise<Json>;
 /**
  * Controller in charge of managing - storing, adding, removing, updating - Messages.
  */
 export declare abstract class AbstractMessageManager<M extends AbstractMessage, P extends AbstractMessageParams, PM extends AbstractMessageParamsMetamask> extends BaseController<BaseConfig, MessageManagerState<M>> {
     protected messages: M[];
+    private securityProviderRequest;
+    private additionalFinishStatuses;
     /**
      * Saves the unapproved messages, and their count to state.
      *
@@ -86,6 +95,13 @@ export declare abstract class AbstractMessageManager<M extends AbstractMessage,
      * @param message - A Message that will replace an existing Message (with the id) in this.messages.
      */
     protected updateMessage(message: M): void;
+    /**
+     * Verifies a message is malicious or not by checking it against a security provider.
+     *
+     * @param message - The message to verify.
+     * @returns A promise that resolves to a secured message with additional security provider response data.
+     */
+    private securityCheck;
     /**
      * EventEmitter instance used to listen to specific message events
      */
@@ -99,8 +115,10 @@ export declare abstract class AbstractMessageManager<M extends AbstractMessage,
      *
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
+     * @param securityProviderRequest - A function for verifying a message, whether it is malicious or not.
+     * @param additionalFinishStatuses - Optional list of statuses that are accepted to emit a finished event.
      */
-    constructor(config?: Partial<BaseConfig>, state?: Partial<MessageManagerState<M>>);
+    constructor(config?: Partial<BaseConfig>, state?: Partial<MessageManagerState<M>>, securityProviderRequest?: SecurityProviderRequest, additionalFinishStatuses?: string[]);
     /**
      * A getter for the number of 'unapproved' Messages in this.messages.
      *
@@ -121,7 +139,7 @@ export declare abstract class AbstractMessageManager<M extends AbstractMessage,
      *
      * @param message - The Message to add to this.messages.
      */
-    addMessage(message: M): void;
+    addMessage(message: M): Promise<void>;
     /**
      * Returns a specified Message.
      *
@@ -154,6 +172,15 @@ export declare abstract class AbstractMessageManager<M extends AbstractMessage,
      * @param rawSig - The raw data of the signature request.
      */
     setMessageStatusSigned(messageId: string, rawSig: string): void;
+    /**
+     * Sets the message to a new status via a call to this.setMsgStatus and
+     * updates the rawSig field in this.messages.
+     *
+     * @param messageId - The id of the Message to sign.
+     * @param rawSig - The data to update rawSig in the message.
+     * @param status - The new message status.
+     */
+    setMessageStatusAndResult(messageId: string, rawSig: string, status: string): void;
     /**
      * Removes the metamaskId property from passed messageParams and returns a promise which
      * resolves the updated messageParams
diff --git a/dist/AbstractMessageManager.js b/dist/AbstractMessageManager.js
index 3b853d88a65798fca595d5a696679288afaaab04..2c3f0ad843b27421d7ffd7c377a05d73c368b385 100644
--- a/dist/AbstractMessageManager.js
+++ b/dist/AbstractMessageManager.js
@@ -1,4 +1,13 @@
 "use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.AbstractMessageManager = void 0;
 const events_1 = require("events");
@@ -12,8 +21,10 @@ class AbstractMessageManager extends base_controller_1.BaseController {
      *
      * @param config - Initial options used to configure this controller.
      * @param state - Initial state to set on this controller.
+     * @param securityProviderRequest - A function for verifying a message, whether it is malicious or not.
+     * @param additionalFinishStatuses - Optional list of statuses that are accepted to emit a finished event.
      */
-    constructor(config, state) {
+    constructor(config, state, securityProviderRequest, additionalFinishStatuses) {
         super(config, state);
         /**
          * EventEmitter instance used to listen to specific message events
@@ -28,6 +39,8 @@ class AbstractMessageManager extends base_controller_1.BaseController {
             unapprovedMessagesCount: 0,
         };
         this.messages = [];
+        this.securityProviderRequest = securityProviderRequest;
+        this.additionalFinishStatuses = additionalFinishStatuses !== null && additionalFinishStatuses !== void 0 ? additionalFinishStatuses : [];
         this.initialize();
     }
     /**
@@ -54,7 +67,10 @@ class AbstractMessageManager extends base_controller_1.BaseController {
         message.status = status;
         this.updateMessage(message);
         this.hub.emit(`${messageId}:${status}`, message);
-        if (status === 'rejected' || status === 'signed' || status === 'errored') {
+        if (status === 'rejected' ||
+            status === 'signed' ||
+            status === 'errored' ||
+            this.additionalFinishStatuses.includes(status)) {
             this.hub.emit(`${messageId}:finished`, message);
         }
     }
@@ -72,6 +88,21 @@ class AbstractMessageManager extends base_controller_1.BaseController {
         }
         this.saveMessageList();
     }
+    /**
+     * Verifies a message is malicious or not by checking it against a security provider.
+     *
+     * @param message - The message to verify.
+     * @returns A promise that resolves to a secured message with additional security provider response data.
+     */
+    securityCheck(message) {
+        return __awaiter(this, void 0, void 0, function* () {
+            if (this.securityProviderRequest) {
+                const securityProviderResponse = yield this.securityProviderRequest(message, message.type);
+                return Object.assign(Object.assign({}, message), { securityProviderResponse });
+            }
+            return message;
+        });
+    }
     /**
      * A getter for the number of 'unapproved' Messages in this.messages.
      *
@@ -100,8 +131,11 @@ class AbstractMessageManager extends base_controller_1.BaseController {
      * @param message - The Message to add to this.messages.
      */
     addMessage(message) {
-        this.messages.push(message);
-        this.saveMessageList();
+        return __awaiter(this, void 0, void 0, function* () {
+            const securedMessage = yield this.securityCheck(message);
+            this.messages.push(securedMessage);
+            this.saveMessageList();
+        });
     }
     /**
      * Returns a specified Message.
@@ -144,6 +178,17 @@ class AbstractMessageManager extends base_controller_1.BaseController {
      * @param rawSig - The raw data of the signature request.
      */
     setMessageStatusSigned(messageId, rawSig) {
+        this.setMessageStatusAndResult(messageId, rawSig, 'signed');
+    }
+    /**
+     * Sets the message to a new status via a call to this.setMsgStatus and
+     * updates the rawSig field in this.messages.
+     *
+     * @param messageId - The id of the Message to sign.
+     * @param rawSig - The data to update rawSig in the message.
+     * @param status - The new message status.
+     */
+    setMessageStatusAndResult(messageId, rawSig, status) {
         const message = this.getMessage(messageId);
         /* istanbul ignore if */
         if (!message) {
@@ -151,7 +196,7 @@ class AbstractMessageManager extends base_controller_1.BaseController {
         }
         message.rawSig = rawSig;
         this.updateMessage(message);
-        this.setMessageStatus(messageId, 'signed');
+        this.setMessageStatus(messageId, status);
     }
     /**
      * Sets a Message status to 'rejected' via a call to this.setMessageStatus.
diff --git a/dist/AbstractMessageManager.js.map b/dist/AbstractMessageManager.js.map
index 2fec0b0c5958eed7226a8c11f17ab8d92e8cfe18..1c1f47273cbacb6e3e0073cd745e583b7acfde63 100644
--- a/dist/AbstractMessageManager.js.map
+++ b/dist/AbstractMessageManager.js.map
@@ -1 +1 @@
-{"version":3,"file":"AbstractMessageManager.js","sourceRoot":"","sources":["../src/AbstractMessageManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport {\n  BaseController,\n  BaseConfig,\n  BaseState,\n} from '@metamask/base-controller';\n\n/**\n * @type OriginalRequest\n *\n * Represents the original request object for adding a message.\n * @property origin? - Is it is specified, represents the origin\n */\nexport interface OriginalRequest {\n  origin?: string;\n}\n\n/**\n * @type Message\n *\n * Represents and contains data about a signing type signature request.\n * @property id - An id to track and identify the message object\n * @property type - The json-prc signing method for which a signature request has been made.\n * A 'Message' which always has a signing type\n * @property rawSig - Raw data of the signature request\n */\nexport interface AbstractMessage {\n  id: string;\n  time: number;\n  status: string;\n  type: string;\n  rawSig?: string;\n}\n\n/**\n * @type MessageParams\n *\n * Represents the parameters to pass to the signing method once the signature request is approved.\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n */\nexport interface AbstractMessageParams {\n  from: string;\n  origin?: string;\n}\n\n/**\n * @type MessageParamsMetamask\n *\n * Represents the parameters to pass to the signing method once the signature request is approved\n * plus data added by MetaMask.\n * @property metamaskId - Added for tracking and identification within MetaMask\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n */\nexport interface AbstractMessageParamsMetamask extends AbstractMessageParams {\n  metamaskId?: string;\n}\n\n/**\n * @type MessageManagerState\n *\n * Message Manager state\n * @property unapprovedMessages - A collection of all Messages in the 'unapproved' state\n * @property unapprovedMessagesCount - The count of all Messages in this.unapprovedMessages\n */\nexport interface MessageManagerState<M extends AbstractMessage>\n  extends BaseState {\n  unapprovedMessages: { [key: string]: M };\n  unapprovedMessagesCount: number;\n}\n\n/**\n * Controller in charge of managing - storing, adding, removing, updating - Messages.\n */\nexport abstract class AbstractMessageManager<\n  M extends AbstractMessage,\n  P extends AbstractMessageParams,\n  PM extends AbstractMessageParamsMetamask,\n> extends BaseController<BaseConfig, MessageManagerState<M>> {\n  protected messages: M[];\n\n  /**\n   * Saves the unapproved messages, and their count to state.\n   *\n   */\n  protected saveMessageList() {\n    const unapprovedMessages = this.getUnapprovedMessages();\n    const unapprovedMessagesCount = this.getUnapprovedMessagesCount();\n    this.update({ unapprovedMessages, unapprovedMessagesCount });\n    this.hub.emit('updateBadge');\n  }\n\n  /**\n   * Updates the status of a Message in this.messages.\n   *\n   * @param messageId - The id of the Message to update.\n   * @param status - The new status of the Message.\n   */\n  protected setMessageStatus(messageId: string, status: string) {\n    const message = this.getMessage(messageId);\n    if (!message) {\n      throw new Error(`${this.name}: Message not found for id: ${messageId}.`);\n    }\n    message.status = status;\n    this.updateMessage(message);\n    this.hub.emit(`${messageId}:${status}`, message);\n    if (status === 'rejected' || status === 'signed' || status === 'errored') {\n      this.hub.emit(`${messageId}:finished`, message);\n    }\n  }\n\n  /**\n   * Sets a Message in this.messages to the passed Message if the ids are equal.\n   * Then saves the unapprovedMessage list to storage.\n   *\n   * @param message - A Message that will replace an existing Message (with the id) in this.messages.\n   */\n  protected updateMessage(message: M) {\n    const index = this.messages.findIndex((msg) => message.id === msg.id);\n    /* istanbul ignore next */\n    if (index !== -1) {\n      this.messages[index] = message;\n    }\n    this.saveMessageList();\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific message events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'AbstractMessageManager';\n\n  /**\n   * Creates an AbstractMessageManager instance.\n   *\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    config?: Partial<BaseConfig>,\n    state?: Partial<MessageManagerState<M>>,\n  ) {\n    super(config, state);\n    this.defaultState = {\n      unapprovedMessages: {},\n      unapprovedMessagesCount: 0,\n    };\n    this.messages = [];\n    this.initialize();\n  }\n\n  /**\n   * A getter for the number of 'unapproved' Messages in this.messages.\n   *\n   * @returns The number of 'unapproved' Messages in this.messages.\n   */\n  getUnapprovedMessagesCount() {\n    return Object.keys(this.getUnapprovedMessages()).length;\n  }\n\n  /**\n   * A getter for the 'unapproved' Messages in state messages.\n   *\n   * @returns An index of Message ids to Messages, for all 'unapproved' Messages in this.messages.\n   */\n  getUnapprovedMessages() {\n    return this.messages\n      .filter((message) => message.status === 'unapproved')\n      .reduce((result: { [key: string]: M }, message: M) => {\n        result[message.id] = message;\n        return result;\n      }, {}) as { [key: string]: M };\n  }\n\n  /**\n   * Adds a passed Message to this.messages, and calls this.saveMessageList() to save\n   * the unapproved Messages from that list to this.messages.\n   *\n   * @param message - The Message to add to this.messages.\n   */\n  addMessage(message: M) {\n    this.messages.push(message);\n    this.saveMessageList();\n  }\n\n  /**\n   * Returns a specified Message.\n   *\n   * @param messageId - The id of the Message to get.\n   * @returns The Message with the id that matches the passed messageId, or undefined\n   * if no Message has that id.\n   */\n  getMessage(messageId: string) {\n    return this.messages.find((message) => message.id === messageId);\n  }\n\n  /**\n   * Approves a Message. Sets the message status via a call to this.setMessageStatusApproved,\n   * and returns a promise with any the message params modified for proper signing.\n   *\n   * @param messageParams - The messageParams to be used when signing method is called,\n   * plus data added by MetaMask.\n   * @returns Promise resolving to the messageParams with the metamaskId property removed.\n   */\n  approveMessage(messageParams: PM): Promise<P> {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    this.setMessageStatusApproved(messageParams.metamaskId);\n    return this.prepMessageForSigning(messageParams);\n  }\n\n  /**\n   * Sets a Message status to 'approved' via a call to this.setMessageStatus.\n   *\n   * @param messageId - The id of the Message to approve.\n   */\n  setMessageStatusApproved(messageId: string) {\n    this.setMessageStatus(messageId, 'approved');\n  }\n\n  /**\n   * Sets a Message status to 'signed' via a call to this.setMessageStatus and updates\n   * that Message in this.messages by adding the raw signature data of the signature\n   * request to the Message.\n   *\n   * @param messageId - The id of the Message to sign.\n   * @param rawSig - The raw data of the signature request.\n   */\n  setMessageStatusSigned(messageId: string, rawSig: string) {\n    const message = this.getMessage(messageId);\n    /* istanbul ignore if */\n    if (!message) {\n      return;\n    }\n    message.rawSig = rawSig;\n    this.updateMessage(message);\n    this.setMessageStatus(messageId, 'signed');\n  }\n\n  /**\n   * Removes the metamaskId property from passed messageParams and returns a promise which\n   * resolves the updated messageParams\n   *\n   * @param messageParams - The messageParams to modify\n   * @returns Promise resolving to the messageParams with the metamaskId property removed\n   */\n  abstract prepMessageForSigning(messageParams: PM): Promise<P>;\n\n  /**\n   * Sets a Message status to 'rejected' via a call to this.setMessageStatus.\n   *\n   * @param messageId - The id of the Message to reject.\n   */\n  rejectMessage(messageId: string) {\n    this.setMessageStatus(messageId, 'rejected');\n  }\n}\n\nexport default AbstractMessageManager;\n"]}
\ No newline at end of file
+{"version":3,"file":"AbstractMessageManager.js","sourceRoot":"","sources":["../src/AbstractMessageManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport {\n  BaseController,\n  BaseConfig,\n  BaseState,\n} from '@metamask/base-controller';\nimport { Json } from '@metamask/controller-utils';\n\n/**\n * @type OriginalRequest\n *\n * Represents the original request object for adding a message.\n * @property origin? - Is it is specified, represents the origin\n */\nexport interface OriginalRequest {\n  origin?: string;\n}\n\n/**\n * @type Message\n *\n * Represents and contains data about a signing type signature request.\n * @property id - An id to track and identify the message object\n * @property type - The json-prc signing method for which a signature request has been made.\n * A 'Message' which always has a signing type\n * @property rawSig - Raw data of the signature request\n * @property securityProviderResponse - Response from a security provider, whether it is malicious or not\n */\nexport interface AbstractMessage {\n  id: string;\n  time: number;\n  status: string;\n  type: string;\n  rawSig?: string;\n  securityProviderResponse?: Map<string, Json>;\n}\n\n/**\n * @type MessageParams\n *\n * Represents the parameters to pass to the signing method once the signature request is approved.\n * @property from - Address from which the message is processed\n * @property origin? - Added for request origin identification\n */\nexport interface AbstractMessageParams {\n  from: string;\n  origin?: string;\n}\n\n/**\n * @type MessageParamsMetamask\n *\n * Represents the parameters to pass to the signing method once the signature request is approved\n * plus data added by MetaMask.\n * @property metamaskId - Added for tracking and identification within MetaMask\n * @property from - Address from which the message is processed\n * @property origin? - Added for request origin identification\n */\nexport interface AbstractMessageParamsMetamask extends AbstractMessageParams {\n  metamaskId?: string;\n}\n\n/**\n * @type MessageManagerState\n *\n * Message Manager state\n * @property unapprovedMessages - A collection of all Messages in the 'unapproved' state\n * @property unapprovedMessagesCount - The count of all Messages in this.unapprovedMessages\n */\nexport interface MessageManagerState<M extends AbstractMessage>\n  extends BaseState {\n  unapprovedMessages: { [key: string]: M };\n  unapprovedMessagesCount: number;\n}\n\n/**\n * A function for verifying a message, whether it is malicious or not\n */\nexport type SecurityProviderRequest = (\n  requestData: AbstractMessage,\n  messageType: string,\n) => Promise<Json>;\n\n/**\n * Controller in charge of managing - storing, adding, removing, updating - Messages.\n */\nexport abstract class AbstractMessageManager<\n  M extends AbstractMessage,\n  P extends AbstractMessageParams,\n  PM extends AbstractMessageParamsMetamask,\n> extends BaseController<BaseConfig, MessageManagerState<M>> {\n  protected messages: M[];\n\n  private securityProviderRequest: SecurityProviderRequest | undefined;\n\n  private additionalFinishStatuses: string[];\n\n  /**\n   * Saves the unapproved messages, and their count to state.\n   *\n   */\n  protected saveMessageList() {\n    const unapprovedMessages = this.getUnapprovedMessages();\n    const unapprovedMessagesCount = this.getUnapprovedMessagesCount();\n    this.update({ unapprovedMessages, unapprovedMessagesCount });\n    this.hub.emit('updateBadge');\n  }\n\n  /**\n   * Updates the status of a Message in this.messages.\n   *\n   * @param messageId - The id of the Message to update.\n   * @param status - The new status of the Message.\n   */\n  protected setMessageStatus(messageId: string, status: string) {\n    const message = this.getMessage(messageId);\n    if (!message) {\n      throw new Error(`${this.name}: Message not found for id: ${messageId}.`);\n    }\n    message.status = status;\n    this.updateMessage(message);\n    this.hub.emit(`${messageId}:${status}`, message);\n    if (\n      status === 'rejected' ||\n      status === 'signed' ||\n      status === 'errored' ||\n      this.additionalFinishStatuses.includes(status)\n    ) {\n      this.hub.emit(`${messageId}:finished`, message);\n    }\n  }\n\n  /**\n   * Sets a Message in this.messages to the passed Message if the ids are equal.\n   * Then saves the unapprovedMessage list to storage.\n   *\n   * @param message - A Message that will replace an existing Message (with the id) in this.messages.\n   */\n  protected updateMessage(message: M) {\n    const index = this.messages.findIndex((msg) => message.id === msg.id);\n    /* istanbul ignore next */\n    if (index !== -1) {\n      this.messages[index] = message;\n    }\n    this.saveMessageList();\n  }\n\n  /**\n   * Verifies a message is malicious or not by checking it against a security provider.\n   *\n   * @param message - The message to verify.\n   * @returns A promise that resolves to a secured message with additional security provider response data.\n   */\n  private async securityCheck(message: M): Promise<M> {\n    if (this.securityProviderRequest) {\n      const securityProviderResponse = await this.securityProviderRequest(\n        message,\n        message.type,\n      );\n      return {\n        ...message,\n        securityProviderResponse,\n      };\n    }\n    return message;\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific message events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'AbstractMessageManager';\n\n  /**\n   * Creates an AbstractMessageManager instance.\n   *\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   * @param securityProviderRequest - A function for verifying a message, whether it is malicious or not.\n   * @param additionalFinishStatuses - Optional list of statuses that are accepted to emit a finished event.\n   */\n  constructor(\n    config?: Partial<BaseConfig>,\n    state?: Partial<MessageManagerState<M>>,\n    securityProviderRequest?: SecurityProviderRequest,\n    additionalFinishStatuses?: string[],\n  ) {\n    super(config, state);\n    this.defaultState = {\n      unapprovedMessages: {},\n      unapprovedMessagesCount: 0,\n    };\n    this.messages = [];\n    this.securityProviderRequest = securityProviderRequest;\n    this.additionalFinishStatuses = additionalFinishStatuses ?? [];\n    this.initialize();\n  }\n\n  /**\n   * A getter for the number of 'unapproved' Messages in this.messages.\n   *\n   * @returns The number of 'unapproved' Messages in this.messages.\n   */\n  getUnapprovedMessagesCount() {\n    return Object.keys(this.getUnapprovedMessages()).length;\n  }\n\n  /**\n   * A getter for the 'unapproved' Messages in state messages.\n   *\n   * @returns An index of Message ids to Messages, for all 'unapproved' Messages in this.messages.\n   */\n  getUnapprovedMessages() {\n    return this.messages\n      .filter((message) => message.status === 'unapproved')\n      .reduce((result: { [key: string]: M }, message: M) => {\n        result[message.id] = message;\n        return result;\n      }, {}) as { [key: string]: M };\n  }\n\n  /**\n   * Adds a passed Message to this.messages, and calls this.saveMessageList() to save\n   * the unapproved Messages from that list to this.messages.\n   *\n   * @param message - The Message to add to this.messages.\n   */\n  async addMessage(message: M) {\n    const securedMessage = await this.securityCheck(message);\n    this.messages.push(securedMessage);\n    this.saveMessageList();\n  }\n\n  /**\n   * Returns a specified Message.\n   *\n   * @param messageId - The id of the Message to get.\n   * @returns The Message with the id that matches the passed messageId, or undefined\n   * if no Message has that id.\n   */\n  getMessage(messageId: string) {\n    return this.messages.find((message) => message.id === messageId);\n  }\n\n  /**\n   * Approves a Message. Sets the message status via a call to this.setMessageStatusApproved,\n   * and returns a promise with any the message params modified for proper signing.\n   *\n   * @param messageParams - The messageParams to be used when signing method is called,\n   * plus data added by MetaMask.\n   * @returns Promise resolving to the messageParams with the metamaskId property removed.\n   */\n  approveMessage(messageParams: PM): Promise<P> {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    this.setMessageStatusApproved(messageParams.metamaskId);\n    return this.prepMessageForSigning(messageParams);\n  }\n\n  /**\n   * Sets a Message status to 'approved' via a call to this.setMessageStatus.\n   *\n   * @param messageId - The id of the Message to approve.\n   */\n  setMessageStatusApproved(messageId: string) {\n    this.setMessageStatus(messageId, 'approved');\n  }\n\n  /**\n   * Sets a Message status to 'signed' via a call to this.setMessageStatus and updates\n   * that Message in this.messages by adding the raw signature data of the signature\n   * request to the Message.\n   *\n   * @param messageId - The id of the Message to sign.\n   * @param rawSig - The raw data of the signature request.\n   */\n  setMessageStatusSigned(messageId: string, rawSig: string) {\n    this.setMessageStatusAndResult(messageId, rawSig, 'signed');\n  }\n\n  /**\n   * Sets the message to a new status via a call to this.setMsgStatus and\n   * updates the rawSig field in this.messages.\n   *\n   * @param messageId - The id of the Message to sign.\n   * @param rawSig - The data to update rawSig in the message.\n   * @param status - The new message status.\n   */\n  setMessageStatusAndResult(messageId: string, rawSig: string, status: string) {\n    const message = this.getMessage(messageId);\n    /* istanbul ignore if */\n    if (!message) {\n      return;\n    }\n    message.rawSig = rawSig;\n    this.updateMessage(message);\n    this.setMessageStatus(messageId, status);\n  }\n\n  /**\n   * Removes the metamaskId property from passed messageParams and returns a promise which\n   * resolves the updated messageParams\n   *\n   * @param messageParams - The messageParams to modify\n   * @returns Promise resolving to the messageParams with the metamaskId property removed\n   */\n  abstract prepMessageForSigning(messageParams: PM): Promise<P>;\n\n  /**\n   * Sets a Message status to 'rejected' via a call to this.setMessageStatus.\n   *\n   * @param messageId - The id of the Message to reject.\n   */\n  rejectMessage(messageId: string) {\n    this.setMessageStatus(messageId, 'rejected');\n  }\n}\n\nexport default AbstractMessageManager;\n"]}
\ No newline at end of file
diff --git a/dist/EncryptionPublicKeyManager.d.ts b/dist/EncryptionPublicKeyManager.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45852f0e420310bae37357f30a9de1d4173deea3
--- /dev/null
+++ b/dist/EncryptionPublicKeyManager.d.ts
@@ -0,0 +1,74 @@
+import { AbstractMessageManager, AbstractMessage, AbstractMessageParams, AbstractMessageParamsMetamask, OriginalRequest } from './AbstractMessageManager';
+/**
+ * @type EncryptionPublicKey
+ *
+ * Represents and contains data about a 'eth_getEncryptionPublicKey' type request.
+ * These are created when an encryption public key is requested.
+ * @property id - An id to track and identify the message object
+ * @property messageParams - The parameters to pass to the eth_getEncryptionPublicKey method once the request is approved
+ * @property type - The json-prc method for which an encryption public key request has been made.
+ * A 'Message' which always has a 'eth_getEncryptionPublicKey' type
+ * @property rawSig - Encryption public key
+ */
+export interface EncryptionPublicKey extends AbstractMessage {
+    messageParams: EncryptionPublicKeyParams;
+}
+/**
+ * @type EncryptionPublicKeyParams
+ *
+ * Represents the parameters to pass to the method once the request is approved.
+ * @property from - Address from which to extract the encryption public key
+ * @property origin? - Added for request origin identification
+ */
+export declare type EncryptionPublicKeyParams = AbstractMessageParams;
+/**
+ * @type MessageParamsMetamask
+ *
+ * Represents the parameters to pass to the eth_getEncryptionPublicKey method once the request is approved
+ * plus data added by MetaMask.
+ * @property metamaskId - Added for tracking and identification within MetaMask
+ * @property data - Encryption public key
+ * @property from - Address from which to extract the encryption public key
+ * @property origin? - Added for request origin identification
+ */
+export interface EncryptionPublicKeyParamsMetamask extends AbstractMessageParamsMetamask {
+    data: string;
+}
+/**
+ * Controller in charge of managing - storing, adding, removing, updating - Messages.
+ */
+export declare class EncryptionPublicKeyManager extends AbstractMessageManager<EncryptionPublicKey, EncryptionPublicKeyParams, EncryptionPublicKeyParamsMetamask> {
+    /**
+     * Name of this controller used during composition
+     */
+    name: string;
+    /**
+     * Creates a new Message with an 'unapproved' status using the passed messageParams.
+     * this.addMessage is called to add the new Message to this.messages, and to save the unapproved Messages.
+     *
+     * @param messageParams - The params for the eth_getEncryptionPublicKey call to be made after the message is approved.
+     * @param req - The original request object possibly containing the origin.
+     * @returns Promise resolving to the raw data of the request.
+     */
+    addUnapprovedMessageAsync(messageParams: EncryptionPublicKeyParams, req?: OriginalRequest): Promise<string>;
+    /**
+     * Creates a new Message with an 'unapproved' status using the passed messageParams.
+     * this.addMessage is called to add the new Message to this.messages, and to save the
+     * unapproved Messages.
+     *
+     * @param messageParams - The params for the eth_getEncryptionPublicKey call to be made after the message
+     * is approved.
+     * @param req - The original request object possibly containing the origin.
+     * @returns The id of the newly created message.
+     */
+    addUnapprovedMessage(messageParams: EncryptionPublicKeyParams, req?: OriginalRequest): Promise<string>;
+    /**
+     * Removes the metamaskId property from passed messageParams and returns a promise which
+     * resolves the updated messageParams.
+     *
+     * @param messageParams - The messageParams to modify.
+     * @returns Promise resolving to the messageParams with the metamaskId property removed.
+     */
+    prepMessageForSigning(messageParams: EncryptionPublicKeyParamsMetamask): Promise<EncryptionPublicKeyParams>;
+}
+export default EncryptionPublicKeyManager;
diff --git a/dist/EncryptionPublicKeyManager.js b/dist/EncryptionPublicKeyManager.js
new file mode 100644
index 0000000000000000000000000000000000000000..881f4f630664ba5aa3c2c6f8f9c2599d523ab9bd
--- /dev/null
+++ b/dist/EncryptionPublicKeyManager.js
@@ -0,0 +1,95 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.EncryptionPublicKeyManager = void 0;
+const uuid_1 = require("uuid");
+const AbstractMessageManager_1 = require("./AbstractMessageManager");
+const utils_1 = require("./utils");
+/**
+ * Controller in charge of managing - storing, adding, removing, updating - Messages.
+ */
+class EncryptionPublicKeyManager extends AbstractMessageManager_1.AbstractMessageManager {
+    constructor() {
+        super(...arguments);
+        /**
+         * Name of this controller used during composition
+         */
+        this.name = 'EncryptionPublicKeyManager';
+    }
+    /**
+     * Creates a new Message with an 'unapproved' status using the passed messageParams.
+     * this.addMessage is called to add the new Message to this.messages, and to save the unapproved Messages.
+     *
+     * @param messageParams - The params for the eth_getEncryptionPublicKey call to be made after the message is approved.
+     * @param req - The original request object possibly containing the origin.
+     * @returns Promise resolving to the raw data of the request.
+     */
+    addUnapprovedMessageAsync(messageParams, req) {
+        return __awaiter(this, void 0, void 0, function* () {
+            (0, utils_1.validateEncryptionPublicKeyMessageData)(messageParams);
+            const messageId = yield this.addUnapprovedMessage(messageParams, req);
+            return new Promise((resolve, reject) => {
+                this.hub.once(`${messageId}:finished`, (data) => {
+                    switch (data.status) {
+                        case 'received':
+                            return resolve(data.rawSig);
+                        case 'rejected':
+                            return reject(new Error('MetaMask EncryptionPublicKey: User denied message EncryptionPublicKey.'));
+                        default:
+                            return reject(new Error(`MetaMask EncryptionPublicKey: Unknown problem: ${JSON.stringify(messageParams)}`));
+                    }
+                });
+            });
+        });
+    }
+    /**
+     * Creates a new Message with an 'unapproved' status using the passed messageParams.
+     * this.addMessage is called to add the new Message to this.messages, and to save the
+     * unapproved Messages.
+     *
+     * @param messageParams - The params for the eth_getEncryptionPublicKey call to be made after the message
+     * is approved.
+     * @param req - The original request object possibly containing the origin.
+     * @returns The id of the newly created message.
+     */
+    addUnapprovedMessage(messageParams, req) {
+        return __awaiter(this, void 0, void 0, function* () {
+            if (req) {
+                messageParams.origin = req.origin;
+            }
+            const messageId = (0, uuid_1.v1)();
+            const messageData = {
+                id: messageId,
+                messageParams,
+                status: 'unapproved',
+                time: Date.now(),
+                type: 'eth_getEncryptionPublicKey',
+            };
+            yield this.addMessage(messageData);
+            this.hub.emit(`unapprovedMessage`, Object.assign(Object.assign({}, messageParams), { metamaskId: messageId }));
+            return messageId;
+        });
+    }
+    /**
+     * Removes the metamaskId property from passed messageParams and returns a promise which
+     * resolves the updated messageParams.
+     *
+     * @param messageParams - The messageParams to modify.
+     * @returns Promise resolving to the messageParams with the metamaskId property removed.
+     */
+    prepMessageForSigning(messageParams) {
+        delete messageParams.metamaskId;
+        return Promise.resolve({ from: messageParams.data });
+    }
+}
+exports.EncryptionPublicKeyManager = EncryptionPublicKeyManager;
+exports.default = EncryptionPublicKeyManager;
+//# sourceMappingURL=EncryptionPublicKeyManager.js.map
\ No newline at end of file
diff --git a/dist/EncryptionPublicKeyManager.js.map b/dist/EncryptionPublicKeyManager.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..92253d2d28f35e96865121e3ff1ff5ab863a45bb
--- /dev/null
+++ b/dist/EncryptionPublicKeyManager.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"EncryptionPublicKeyManager.js","sourceRoot":"","sources":["../src/EncryptionPublicKeyManager.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,+BAAoC;AACpC,qEAMkC;AAClC,mCAAiE;AAyCjE;;GAEG;AACH,MAAa,0BAA2B,SAAQ,+CAI/C;IAJD;;QAKE;;WAEG;QACM,SAAI,GAAG,4BAA4B,CAAC;IAuF/C,CAAC;IArFC;;;;;;;OAOG;IACG,yBAAyB,CAC7B,aAAwC,EACxC,GAAqB;;YAErB,IAAA,8CAAsC,EAAC,aAAa,CAAC,CAAC;YACtD,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,oBAAoB,CAAC,aAAa,EAAE,GAAG,CAAC,CAAC;YAEtE,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;gBACrC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,SAAS,WAAW,EAAE,CAAC,IAAyB,EAAE,EAAE;oBACnE,QAAQ,IAAI,CAAC,MAAM,EAAE;wBACnB,KAAK,UAAU;4BACb,OAAO,OAAO,CAAC,IAAI,CAAC,MAAgB,CAAC,CAAC;wBACxC,KAAK,UAAU;4BACb,OAAO,MAAM,CACX,IAAI,KAAK,CACP,wEAAwE,CACzE,CACF,CAAC;wBACJ;4BACE,OAAO,MAAM,CACX,IAAI,KAAK,CACP,kDAAkD,IAAI,CAAC,SAAS,CAC9D,aAAa,CACd,EAAE,CACJ,CACF,CAAC;qBACL;gBACH,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;QACL,CAAC;KAAA;IAED;;;;;;;;;OASG;IACG,oBAAoB,CACxB,aAAwC,EACxC,GAAqB;;YAErB,IAAI,GAAG,EAAE;gBACP,aAAa,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC;aACnC;YACD,MAAM,SAAS,GAAG,IAAA,SAAM,GAAE,CAAC;YAC3B,MAAM,WAAW,GAAwB;gBACvC,EAAE,EAAE,SAAS;gBACb,aAAa;gBACb,MAAM,EAAE,YAAY;gBACpB,IAAI,EAAE,IAAI,CAAC,GAAG,EAAE;gBAChB,IAAI,EAAE,4BAA4B;aACnC,CAAC;YACF,MAAM,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;YACnC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,mBAAmB,kCAC5B,aAAa,GACb,EAAE,UAAU,EAAE,SAAS,EAAE,EAC5B,CAAC;YACH,OAAO,SAAS,CAAC;QACnB,CAAC;KAAA;IAED;;;;;;OAMG;IACH,qBAAqB,CACnB,aAAgD;QAEhD,OAAO,aAAa,CAAC,UAAU,CAAC;QAChC,OAAO,OAAO,CAAC,OAAO,CAAC,EAAE,IAAI,EAAE,aAAa,CAAC,IAAI,EAAE,CAAC,CAAC;IACvD,CAAC;CACF;AA/FD,gEA+FC;AAED,kBAAe,0BAA0B,CAAC","sourcesContent":["import { v1 as random } from 'uuid';\nimport {\n  AbstractMessageManager,\n  AbstractMessage,\n  AbstractMessageParams,\n  AbstractMessageParamsMetamask,\n  OriginalRequest,\n} from './AbstractMessageManager';\nimport { validateEncryptionPublicKeyMessageData } from './utils';\n\n/**\n * @type EncryptionPublicKey\n *\n * Represents and contains data about a 'eth_getEncryptionPublicKey' type request.\n * These are created when an encryption public key is requested.\n * @property id - An id to track and identify the message object\n * @property messageParams - The parameters to pass to the eth_getEncryptionPublicKey method once the request is approved\n * @property type - The json-prc method for which an encryption public key request has been made.\n * A 'Message' which always has a 'eth_getEncryptionPublicKey' type\n * @property rawSig - Encryption public key\n */\nexport interface EncryptionPublicKey extends AbstractMessage {\n  messageParams: EncryptionPublicKeyParams;\n}\n\n/**\n * @type EncryptionPublicKeyParams\n *\n * Represents the parameters to pass to the method once the request is approved.\n * @property from - Address from which to extract the encryption public key\n * @property origin? - Added for request origin identification\n */\nexport type EncryptionPublicKeyParams = AbstractMessageParams;\n\n/**\n * @type MessageParamsMetamask\n *\n * Represents the parameters to pass to the eth_getEncryptionPublicKey method once the request is approved\n * plus data added by MetaMask.\n * @property metamaskId - Added for tracking and identification within MetaMask\n * @property data - Encryption public key\n * @property from - Address from which to extract the encryption public key\n * @property origin? - Added for request origin identification\n */\nexport interface EncryptionPublicKeyParamsMetamask\n  extends AbstractMessageParamsMetamask {\n  data: string;\n}\n\n/**\n * Controller in charge of managing - storing, adding, removing, updating - Messages.\n */\nexport class EncryptionPublicKeyManager extends AbstractMessageManager<\n  EncryptionPublicKey,\n  EncryptionPublicKeyParams,\n  EncryptionPublicKeyParamsMetamask\n> {\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'EncryptionPublicKeyManager';\n\n  /**\n   * Creates a new Message with an 'unapproved' status using the passed messageParams.\n   * this.addMessage is called to add the new Message to this.messages, and to save the unapproved Messages.\n   *\n   * @param messageParams - The params for the eth_getEncryptionPublicKey call to be made after the message is approved.\n   * @param req - The original request object possibly containing the origin.\n   * @returns Promise resolving to the raw data of the request.\n   */\n  async addUnapprovedMessageAsync(\n    messageParams: EncryptionPublicKeyParams,\n    req?: OriginalRequest,\n  ): Promise<string> {\n    validateEncryptionPublicKeyMessageData(messageParams);\n    const messageId = await this.addUnapprovedMessage(messageParams, req);\n\n    return new Promise((resolve, reject) => {\n      this.hub.once(`${messageId}:finished`, (data: EncryptionPublicKey) => {\n        switch (data.status) {\n          case 'received':\n            return resolve(data.rawSig as string);\n          case 'rejected':\n            return reject(\n              new Error(\n                'MetaMask EncryptionPublicKey: User denied message EncryptionPublicKey.',\n              ),\n            );\n          default:\n            return reject(\n              new Error(\n                `MetaMask EncryptionPublicKey: Unknown problem: ${JSON.stringify(\n                  messageParams,\n                )}`,\n              ),\n            );\n        }\n      });\n    });\n  }\n\n  /**\n   * Creates a new Message with an 'unapproved' status using the passed messageParams.\n   * this.addMessage is called to add the new Message to this.messages, and to save the\n   * unapproved Messages.\n   *\n   * @param messageParams - The params for the eth_getEncryptionPublicKey call to be made after the message\n   * is approved.\n   * @param req - The original request object possibly containing the origin.\n   * @returns The id of the newly created message.\n   */\n  async addUnapprovedMessage(\n    messageParams: EncryptionPublicKeyParams,\n    req?: OriginalRequest,\n  ): Promise<string> {\n    if (req) {\n      messageParams.origin = req.origin;\n    }\n    const messageId = random();\n    const messageData: EncryptionPublicKey = {\n      id: messageId,\n      messageParams,\n      status: 'unapproved',\n      time: Date.now(),\n      type: 'eth_getEncryptionPublicKey',\n    };\n    await this.addMessage(messageData);\n    this.hub.emit(`unapprovedMessage`, {\n      ...messageParams,\n      ...{ metamaskId: messageId },\n    });\n    return messageId;\n  }\n\n  /**\n   * Removes the metamaskId property from passed messageParams and returns a promise which\n   * resolves the updated messageParams.\n   *\n   * @param messageParams - The messageParams to modify.\n   * @returns Promise resolving to the messageParams with the metamaskId property removed.\n   */\n  prepMessageForSigning(\n    messageParams: EncryptionPublicKeyParamsMetamask,\n  ): Promise<EncryptionPublicKeyParams> {\n    delete messageParams.metamaskId;\n    return Promise.resolve({ from: messageParams.data });\n  }\n}\n\nexport default EncryptionPublicKeyManager;\n"]}
\ No newline at end of file
diff --git a/dist/MessageManager.d.ts b/dist/MessageManager.d.ts
index c8fb2fbe01abd71da10196854489dd7e3029e581..71a3ddc01f4ef1945a85011c24b97df9f0257fad 100644
--- a/dist/MessageManager.d.ts
+++ b/dist/MessageManager.d.ts
@@ -64,7 +64,7 @@ export declare class MessageManager extends AbstractMessageManager<Message, Mess
      * @param req - The original request object possibly containing the origin.
      * @returns The id of the newly created message.
      */
-    addUnapprovedMessage(messageParams: MessageParams, req?: OriginalRequest): string;
+    addUnapprovedMessage(messageParams: MessageParams, req?: OriginalRequest): Promise<string>;
     /**
      * Removes the metamaskId property from passed messageParams and returns a promise which
      * resolves the updated messageParams.
diff --git a/dist/MessageManager.js b/dist/MessageManager.js
index e7c5d9948e00111fb350bea545ef3dcee628474b..5518479a9eb7387dcdeea6572e8c48ba00e283ef 100644
--- a/dist/MessageManager.js
+++ b/dist/MessageManager.js
@@ -1,4 +1,13 @@
 "use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.MessageManager = void 0;
 const uuid_1 = require("uuid");
@@ -24,18 +33,20 @@ class MessageManager extends AbstractMessageManager_1.AbstractMessageManager {
      * @returns Promise resolving to the raw data of the signature request.
      */
     addUnapprovedMessageAsync(messageParams, req) {
-        return new Promise((resolve, reject) => {
+        return __awaiter(this, void 0, void 0, function* () {
             (0, utils_1.validateSignMessageData)(messageParams);
-            const messageId = this.addUnapprovedMessage(messageParams, req);
-            this.hub.once(`${messageId}:finished`, (data) => {
-                switch (data.status) {
-                    case 'signed':
-                        return resolve(data.rawSig);
-                    case 'rejected':
-                        return reject(new Error('MetaMask Message Signature: User denied message signature.'));
-                    default:
-                        return reject(new Error(`MetaMask Message Signature: Unknown problem: ${JSON.stringify(messageParams)}`));
-                }
+            const messageId = yield this.addUnapprovedMessage(messageParams, req);
+            return new Promise((resolve, reject) => {
+                this.hub.once(`${messageId}:finished`, (data) => {
+                    switch (data.status) {
+                        case 'signed':
+                            return resolve(data.rawSig);
+                        case 'rejected':
+                            return reject(new Error('MetaMask Message Signature: User denied message signature.'));
+                        default:
+                            return reject(new Error(`MetaMask Message Signature: Unknown problem: ${JSON.stringify(messageParams)}`));
+                    }
+                });
             });
         });
     }
@@ -50,21 +61,23 @@ class MessageManager extends AbstractMessageManager_1.AbstractMessageManager {
      * @returns The id of the newly created message.
      */
     addUnapprovedMessage(messageParams, req) {
-        if (req) {
-            messageParams.origin = req.origin;
-        }
-        messageParams.data = (0, utils_1.normalizeMessageData)(messageParams.data);
-        const messageId = (0, uuid_1.v1)();
-        const messageData = {
-            id: messageId,
-            messageParams,
-            status: 'unapproved',
-            time: Date.now(),
-            type: 'eth_sign',
-        };
-        this.addMessage(messageData);
-        this.hub.emit(`unapprovedMessage`, Object.assign(Object.assign({}, messageParams), { metamaskId: messageId }));
-        return messageId;
+        return __awaiter(this, void 0, void 0, function* () {
+            if (req) {
+                messageParams.origin = req.origin;
+            }
+            messageParams.data = (0, utils_1.normalizeMessageData)(messageParams.data);
+            const messageId = (0, uuid_1.v1)();
+            const messageData = {
+                id: messageId,
+                messageParams,
+                status: 'unapproved',
+                time: Date.now(),
+                type: 'eth_sign',
+            };
+            yield this.addMessage(messageData);
+            this.hub.emit(`unapprovedMessage`, Object.assign(Object.assign({}, messageParams), { metamaskId: messageId }));
+            return messageId;
+        });
     }
     /**
      * Removes the metamaskId property from passed messageParams and returns a promise which
diff --git a/dist/MessageManager.js.map b/dist/MessageManager.js.map
index 18dac6fe1289e47b01eefcfdbf8ca5a232f1cfa9..688c05a2ee2fd3c21a9d03374ae2f2a9fa5bd15b 100644
--- a/dist/MessageManager.js.map
+++ b/dist/MessageManager.js.map
@@ -1 +1 @@
-{"version":3,"file":"MessageManager.js","sourceRoot":"","sources":["../src/MessageManager.ts"],"names":[],"mappings":";;;AAAA,+BAAoC;AACpC,qEAMkC;AAClC,mCAAwE;AA2CxE;;GAEG;AACH,MAAa,cAAe,SAAQ,+CAInC;IAJD;;QAKE;;WAEG;QACM,SAAI,GAAG,gBAAgB,CAAC;IAoFnC,CAAC;IAlFC;;;;;;;OAOG;IACH,yBAAyB,CACvB,aAA4B,EAC5B,GAAqB;QAErB,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACrC,IAAA,+BAAuB,EAAC,aAAa,CAAC,CAAC;YACvC,MAAM,SAAS,GAAG,IAAI,CAAC,oBAAoB,CAAC,aAAa,EAAE,GAAG,CAAC,CAAC;YAChE,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,SAAS,WAAW,EAAE,CAAC,IAAa,EAAE,EAAE;gBACvD,QAAQ,IAAI,CAAC,MAAM,EAAE;oBACnB,KAAK,QAAQ;wBACX,OAAO,OAAO,CAAC,IAAI,CAAC,MAAgB,CAAC,CAAC;oBACxC,KAAK,UAAU;wBACb,OAAO,MAAM,CACX,IAAI,KAAK,CACP,4DAA4D,CAC7D,CACF,CAAC;oBACJ;wBACE,OAAO,MAAM,CACX,IAAI,KAAK,CACP,gDAAgD,IAAI,CAAC,SAAS,CAC5D,aAAa,CACd,EAAE,CACJ,CACF,CAAC;iBACL;YACH,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;;;;;;OASG;IACH,oBAAoB,CAAC,aAA4B,EAAE,GAAqB;QACtE,IAAI,GAAG,EAAE;YACP,aAAa,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC;SACnC;QACD,aAAa,CAAC,IAAI,GAAG,IAAA,4BAAoB,EAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QAC9D,MAAM,SAAS,GAAG,IAAA,SAAM,GAAE,CAAC;QAC3B,MAAM,WAAW,GAAY;YAC3B,EAAE,EAAE,SAAS;YACb,aAAa;YACb,MAAM,EAAE,YAAY;YACpB,IAAI,EAAE,IAAI,CAAC,GAAG,EAAE;YAChB,IAAI,EAAE,UAAU;SACjB,CAAC;QACF,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;QAC7B,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,mBAAmB,kCAC5B,aAAa,GACb,EAAE,UAAU,EAAE,SAAS,EAAE,EAC5B,CAAC;QACH,OAAO,SAAS,CAAC;IACnB,CAAC;IAED;;;;;;OAMG;IACH,qBAAqB,CACnB,aAAoC;QAEpC,OAAO,aAAa,CAAC,UAAU,CAAC;QAChC,OAAO,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;IACxC,CAAC;CACF;AA5FD,wCA4FC;AAED,kBAAe,cAAc,CAAC","sourcesContent":["import { v1 as random } from 'uuid';\nimport {\n  AbstractMessageManager,\n  AbstractMessage,\n  AbstractMessageParams,\n  AbstractMessageParamsMetamask,\n  OriginalRequest,\n} from './AbstractMessageManager';\nimport { normalizeMessageData, validateSignMessageData } from './utils';\n\n/**\n * @type Message\n *\n * Represents and contains data about a 'eth_sign' type signature request.\n * These are created when a signature for an eth_sign call is requested.\n * @property id - An id to track and identify the message object\n * @property messageParams - The parameters to pass to the eth_sign method once the signature request is approved\n * @property type - The json-prc signing method for which a signature request has been made.\n * A 'Message' which always has a 'eth_sign' type\n * @property rawSig - Raw data of the signature request\n */\nexport interface Message extends AbstractMessage {\n  messageParams: MessageParams;\n}\n\n/**\n * @type PersonalMessageParams\n *\n * Represents the parameters to pass to the eth_sign method once the signature request is approved.\n * @property data - A hex string conversion of the raw buffer data of the signature request\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n */\nexport interface MessageParams extends AbstractMessageParams {\n  data: string;\n}\n\n/**\n * @type MessageParamsMetamask\n *\n * Represents the parameters to pass to the eth_sign method once the signature request is approved\n * plus data added by MetaMask.\n * @property metamaskId - Added for tracking and identification within MetaMask\n * @property data - A hex string conversion of the raw buffer data of the signature request\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n */\nexport interface MessageParamsMetamask extends AbstractMessageParamsMetamask {\n  data: string;\n}\n\n/**\n * Controller in charge of managing - storing, adding, removing, updating - Messages.\n */\nexport class MessageManager extends AbstractMessageManager<\n  Message,\n  MessageParams,\n  MessageParamsMetamask\n> {\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'MessageManager';\n\n  /**\n   * Creates a new Message with an 'unapproved' status using the passed messageParams.\n   * this.addMessage is called to add the new Message to this.messages, and to save the unapproved Messages.\n   *\n   * @param messageParams - The params for the eth_sign call to be made after the message is approved.\n   * @param req - The original request object possibly containing the origin.\n   * @returns Promise resolving to the raw data of the signature request.\n   */\n  addUnapprovedMessageAsync(\n    messageParams: MessageParams,\n    req?: OriginalRequest,\n  ): Promise<string> {\n    return new Promise((resolve, reject) => {\n      validateSignMessageData(messageParams);\n      const messageId = this.addUnapprovedMessage(messageParams, req);\n      this.hub.once(`${messageId}:finished`, (data: Message) => {\n        switch (data.status) {\n          case 'signed':\n            return resolve(data.rawSig as string);\n          case 'rejected':\n            return reject(\n              new Error(\n                'MetaMask Message Signature: User denied message signature.',\n              ),\n            );\n          default:\n            return reject(\n              new Error(\n                `MetaMask Message Signature: Unknown problem: ${JSON.stringify(\n                  messageParams,\n                )}`,\n              ),\n            );\n        }\n      });\n    });\n  }\n\n  /**\n   * Creates a new Message with an 'unapproved' status using the passed messageParams.\n   * this.addMessage is called to add the new Message to this.messages, and to save the\n   * unapproved Messages.\n   *\n   * @param messageParams - The params for the eth_sign call to be made after the message\n   * is approved.\n   * @param req - The original request object possibly containing the origin.\n   * @returns The id of the newly created message.\n   */\n  addUnapprovedMessage(messageParams: MessageParams, req?: OriginalRequest) {\n    if (req) {\n      messageParams.origin = req.origin;\n    }\n    messageParams.data = normalizeMessageData(messageParams.data);\n    const messageId = random();\n    const messageData: Message = {\n      id: messageId,\n      messageParams,\n      status: 'unapproved',\n      time: Date.now(),\n      type: 'eth_sign',\n    };\n    this.addMessage(messageData);\n    this.hub.emit(`unapprovedMessage`, {\n      ...messageParams,\n      ...{ metamaskId: messageId },\n    });\n    return messageId;\n  }\n\n  /**\n   * Removes the metamaskId property from passed messageParams and returns a promise which\n   * resolves the updated messageParams.\n   *\n   * @param messageParams - The messageParams to modify.\n   * @returns Promise resolving to the messageParams with the metamaskId property removed.\n   */\n  prepMessageForSigning(\n    messageParams: MessageParamsMetamask,\n  ): Promise<MessageParams> {\n    delete messageParams.metamaskId;\n    return Promise.resolve(messageParams);\n  }\n}\n\nexport default MessageManager;\n"]}
\ No newline at end of file
+{"version":3,"file":"MessageManager.js","sourceRoot":"","sources":["../src/MessageManager.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,+BAAoC;AACpC,qEAMkC;AAClC,mCAAwE;AA2CxE;;GAEG;AACH,MAAa,cAAe,SAAQ,+CAInC;IAJD;;QAKE;;WAEG;QACM,SAAI,GAAG,gBAAgB,CAAC;IAuFnC,CAAC;IArFC;;;;;;;OAOG;IACG,yBAAyB,CAC7B,aAA4B,EAC5B,GAAqB;;YAErB,IAAA,+BAAuB,EAAC,aAAa,CAAC,CAAC;YACvC,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,oBAAoB,CAAC,aAAa,EAAE,GAAG,CAAC,CAAC;YACtE,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;gBACrC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,SAAS,WAAW,EAAE,CAAC,IAAa,EAAE,EAAE;oBACvD,QAAQ,IAAI,CAAC,MAAM,EAAE;wBACnB,KAAK,QAAQ;4BACX,OAAO,OAAO,CAAC,IAAI,CAAC,MAAgB,CAAC,CAAC;wBACxC,KAAK,UAAU;4BACb,OAAO,MAAM,CACX,IAAI,KAAK,CACP,4DAA4D,CAC7D,CACF,CAAC;wBACJ;4BACE,OAAO,MAAM,CACX,IAAI,KAAK,CACP,gDAAgD,IAAI,CAAC,SAAS,CAC5D,aAAa,CACd,EAAE,CACJ,CACF,CAAC;qBACL;gBACH,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;QACL,CAAC;KAAA;IAED;;;;;;;;;OASG;IACG,oBAAoB,CACxB,aAA4B,EAC5B,GAAqB;;YAErB,IAAI,GAAG,EAAE;gBACP,aAAa,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC;aACnC;YACD,aAAa,CAAC,IAAI,GAAG,IAAA,4BAAoB,EAAC,aAAa,CAAC,IAAI,CAAC,CAAC;YAC9D,MAAM,SAAS,GAAG,IAAA,SAAM,GAAE,CAAC;YAC3B,MAAM,WAAW,GAAY;gBAC3B,EAAE,EAAE,SAAS;gBACb,aAAa;gBACb,MAAM,EAAE,YAAY;gBACpB,IAAI,EAAE,IAAI,CAAC,GAAG,EAAE;gBAChB,IAAI,EAAE,UAAU;aACjB,CAAC;YACF,MAAM,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;YACnC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,mBAAmB,kCAC5B,aAAa,GACb,EAAE,UAAU,EAAE,SAAS,EAAE,EAC5B,CAAC;YACH,OAAO,SAAS,CAAC;QACnB,CAAC;KAAA;IAED;;;;;;OAMG;IACH,qBAAqB,CACnB,aAAoC;QAEpC,OAAO,aAAa,CAAC,UAAU,CAAC;QAChC,OAAO,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;IACxC,CAAC;CACF;AA/FD,wCA+FC;AAED,kBAAe,cAAc,CAAC","sourcesContent":["import { v1 as random } from 'uuid';\nimport {\n  AbstractMessageManager,\n  AbstractMessage,\n  AbstractMessageParams,\n  AbstractMessageParamsMetamask,\n  OriginalRequest,\n} from './AbstractMessageManager';\nimport { normalizeMessageData, validateSignMessageData } from './utils';\n\n/**\n * @type Message\n *\n * Represents and contains data about a 'eth_sign' type signature request.\n * These are created when a signature for an eth_sign call is requested.\n * @property id - An id to track and identify the message object\n * @property messageParams - The parameters to pass to the eth_sign method once the signature request is approved\n * @property type - The json-prc signing method for which a signature request has been made.\n * A 'Message' which always has a 'eth_sign' type\n * @property rawSig - Raw data of the signature request\n */\nexport interface Message extends AbstractMessage {\n  messageParams: MessageParams;\n}\n\n/**\n * @type PersonalMessageParams\n *\n * Represents the parameters to pass to the eth_sign method once the signature request is approved.\n * @property data - A hex string conversion of the raw buffer data of the signature request\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n */\nexport interface MessageParams extends AbstractMessageParams {\n  data: string;\n}\n\n/**\n * @type MessageParamsMetamask\n *\n * Represents the parameters to pass to the eth_sign method once the signature request is approved\n * plus data added by MetaMask.\n * @property metamaskId - Added for tracking and identification within MetaMask\n * @property data - A hex string conversion of the raw buffer data of the signature request\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n */\nexport interface MessageParamsMetamask extends AbstractMessageParamsMetamask {\n  data: string;\n}\n\n/**\n * Controller in charge of managing - storing, adding, removing, updating - Messages.\n */\nexport class MessageManager extends AbstractMessageManager<\n  Message,\n  MessageParams,\n  MessageParamsMetamask\n> {\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'MessageManager';\n\n  /**\n   * Creates a new Message with an 'unapproved' status using the passed messageParams.\n   * this.addMessage is called to add the new Message to this.messages, and to save the unapproved Messages.\n   *\n   * @param messageParams - The params for the eth_sign call to be made after the message is approved.\n   * @param req - The original request object possibly containing the origin.\n   * @returns Promise resolving to the raw data of the signature request.\n   */\n  async addUnapprovedMessageAsync(\n    messageParams: MessageParams,\n    req?: OriginalRequest,\n  ): Promise<string> {\n    validateSignMessageData(messageParams);\n    const messageId = await this.addUnapprovedMessage(messageParams, req);\n    return new Promise((resolve, reject) => {\n      this.hub.once(`${messageId}:finished`, (data: Message) => {\n        switch (data.status) {\n          case 'signed':\n            return resolve(data.rawSig as string);\n          case 'rejected':\n            return reject(\n              new Error(\n                'MetaMask Message Signature: User denied message signature.',\n              ),\n            );\n          default:\n            return reject(\n              new Error(\n                `MetaMask Message Signature: Unknown problem: ${JSON.stringify(\n                  messageParams,\n                )}`,\n              ),\n            );\n        }\n      });\n    });\n  }\n\n  /**\n   * Creates a new Message with an 'unapproved' status using the passed messageParams.\n   * this.addMessage is called to add the new Message to this.messages, and to save the\n   * unapproved Messages.\n   *\n   * @param messageParams - The params for the eth_sign call to be made after the message\n   * is approved.\n   * @param req - The original request object possibly containing the origin.\n   * @returns The id of the newly created message.\n   */\n  async addUnapprovedMessage(\n    messageParams: MessageParams,\n    req?: OriginalRequest,\n  ): Promise<string> {\n    if (req) {\n      messageParams.origin = req.origin;\n    }\n    messageParams.data = normalizeMessageData(messageParams.data);\n    const messageId = random();\n    const messageData: Message = {\n      id: messageId,\n      messageParams,\n      status: 'unapproved',\n      time: Date.now(),\n      type: 'eth_sign',\n    };\n    await this.addMessage(messageData);\n    this.hub.emit(`unapprovedMessage`, {\n      ...messageParams,\n      ...{ metamaskId: messageId },\n    });\n    return messageId;\n  }\n\n  /**\n   * Removes the metamaskId property from passed messageParams and returns a promise which\n   * resolves the updated messageParams.\n   *\n   * @param messageParams - The messageParams to modify.\n   * @returns Promise resolving to the messageParams with the metamaskId property removed.\n   */\n  prepMessageForSigning(\n    messageParams: MessageParamsMetamask,\n  ): Promise<MessageParams> {\n    delete messageParams.metamaskId;\n    return Promise.resolve(messageParams);\n  }\n}\n\nexport default MessageManager;\n"]}
\ No newline at end of file
diff --git a/dist/MessageManager.test copy.d.ts b/dist/MessageManager.test copy.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb0ff5c3b541f646105198ee23ac0fc3d805023e
--- /dev/null
+++ b/dist/MessageManager.test copy.d.ts	
@@ -0,0 +1 @@
+export {};
diff --git a/dist/MessageManager.test copy.js b/dist/MessageManager.test copy.js
new file mode 100644
index 0000000000000000000000000000000000000000..598a13a4d9a3361c59adcd2dded308c1c3a75368
--- /dev/null
+++ b/dist/MessageManager.test copy.js	
@@ -0,0 +1,194 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+const MessageManager_1 = require("./MessageManager");
+describe('PersonalMessageManager', () => {
+    it('should set default state', () => {
+        const controller = new MessageManager_1.MessageManager();
+        expect(controller.state).toStrictEqual({
+            unapprovedMessages: {},
+            unapprovedMessagesCount: 0,
+        });
+    });
+    it('should set default config', () => {
+        const controller = new MessageManager_1.MessageManager();
+        expect(controller.config).toStrictEqual({});
+    });
+    it('should add a valid message', () => __awaiter(void 0, void 0, void 0, function* () {
+        const controller = new MessageManager_1.MessageManager();
+        const messageId = '1';
+        const from = '0x0123';
+        const messageData = '0x123';
+        const messageTime = Date.now();
+        const messageStatus = 'unapproved';
+        const messageType = 'eth_sign';
+        controller.addMessage({
+            id: messageId,
+            messageParams: {
+                data: messageData,
+                from,
+            },
+            status: messageStatus,
+            time: messageTime,
+            type: messageType,
+        });
+        const message = controller.getMessage(messageId);
+        if (!message) {
+            throw new Error('"message" is falsy');
+        }
+        expect(message.id).toBe(messageId);
+        expect(message.messageParams.from).toBe(from);
+        expect(message.messageParams.data).toBe(messageData);
+        expect(message.time).toBe(messageTime);
+        expect(message.status).toBe(messageStatus);
+        expect(message.type).toBe(messageType);
+    }));
+    it('should reject a message', () => __awaiter(void 0, void 0, void 0, function* () {
+        const controller = new MessageManager_1.MessageManager();
+        const from = '0xc38bf1ad06ef69f0c04e29dbeb4152b4175f0a8d';
+        const data = '0x879a053d4800c6354e76c7985a865d2922c82fb5b';
+        const result = controller.addUnapprovedMessageAsync({
+            data,
+            from,
+        });
+        const unapprovedMessages = controller.getUnapprovedMessages();
+        const keys = Object.keys(unapprovedMessages);
+        controller.hub.once(`${keys[0]}:finished`, () => {
+            expect(unapprovedMessages[keys[0]].messageParams.from).toBe(from);
+            expect(unapprovedMessages[keys[0]].status).toBe('rejected');
+        });
+        controller.rejectMessage(keys[0]);
+        yield expect(result).rejects.toThrow('User denied message signature');
+    }));
+    it('should sign a message', () => __awaiter(void 0, void 0, void 0, function* () {
+        const controller = new MessageManager_1.MessageManager();
+        const from = '0xc38bf1ad06ef69f0c04e29dbeb4152b4175f0a8d';
+        const data = '0x879a053d4800c6354e76c7985a865d2922c82fb5b';
+        const rawSig = '0x5f7a0';
+        const result = controller.addUnapprovedMessageAsync({
+            data,
+            from,
+        });
+        const unapprovedMessages = controller.getUnapprovedMessages();
+        const keys = Object.keys(unapprovedMessages);
+        controller.hub.once(`${keys[0]}:finished`, () => {
+            expect(unapprovedMessages[keys[0]].messageParams.from).toBe(from);
+            expect(unapprovedMessages[keys[0]].status).toBe('signed');
+        });
+        controller.setMessageStatusSigned(keys[0], rawSig);
+        const sig = yield result;
+        expect(sig).toBe(rawSig);
+    }));
+    it('should throw when unapproved finishes', () => __awaiter(void 0, void 0, void 0, function* () {
+        const controller = new MessageManager_1.MessageManager();
+        const from = '0xc38bf1ad06ef69f0c04e29dbeb4152b4175f0a8d';
+        const data = '0x879a053d4800c6354e76c7985a865d2922c82fb5b';
+        const result = controller.addUnapprovedMessageAsync({
+            data,
+            from,
+        });
+        const unapprovedMessages = controller.getUnapprovedMessages();
+        const keys = Object.keys(unapprovedMessages);
+        controller.hub.emit(`${keys[0]}:finished`, unapprovedMessages[keys[0]]);
+        yield expect(result).rejects.toThrow('Unknown problem');
+    }));
+    it('should add a valid unapproved message', () => __awaiter(void 0, void 0, void 0, function* () {
+        const controller = new MessageManager_1.MessageManager();
+        const messageStatus = 'unapproved';
+        const messageType = 'eth_sign';
+        const messageParams = {
+            data: '0x123',
+            from: '0xfoO',
+        };
+        const originalRequest = { origin: 'origin' };
+        const messageId = controller.addUnapprovedMessage(messageParams, originalRequest);
+        expect(messageId).not.toBeUndefined();
+        const message = controller.getMessage(messageId);
+        if (!message) {
+            throw new Error('"message" is falsy');
+        }
+        expect(message.messageParams.from).toBe(messageParams.from);
+        expect(message.messageParams.data).toBe(messageParams.data);
+        expect(message.time).not.toBeUndefined();
+        expect(message.status).toBe(messageStatus);
+        expect(message.type).toBe(messageType);
+    }));
+    it('should throw when adding invalid message', () => __awaiter(void 0, void 0, void 0, function* () {
+        const from = 'foo';
+        const messageData = '0x123';
+        const controller = new MessageManager_1.MessageManager();
+        yield expect(controller.addUnapprovedMessageAsync({
+            data: messageData,
+            from,
+        })).rejects.toThrow('Invalid "from" address:');
+    }));
+    it('should get correct unapproved messages', () => {
+        const firstMessage = {
+            id: '1',
+            messageParams: { from: '0x1', data: '0x123' },
+            status: 'unapproved',
+            time: 123,
+            type: 'eth_sign',
+        };
+        const secondMessage = {
+            id: '2',
+            messageParams: { from: '0x1', data: '0x321' },
+            status: 'unapproved',
+            time: 123,
+            type: 'eth_sign',
+        };
+        const controller = new MessageManager_1.MessageManager();
+        controller.addMessage(firstMessage);
+        controller.addMessage(secondMessage);
+        expect(controller.getUnapprovedMessagesCount()).toStrictEqual(2);
+        expect(controller.getUnapprovedMessages()).toStrictEqual({
+            [firstMessage.id]: firstMessage,
+            [secondMessage.id]: secondMessage,
+        });
+    });
+    it('should approve message', () => __awaiter(void 0, void 0, void 0, function* () {
+        const controller = new MessageManager_1.MessageManager();
+        const firstMessage = { from: 'foo', data: '0x123' };
+        const messageId = controller.addUnapprovedMessage(firstMessage);
+        const messageParams = yield controller.approveMessage(Object.assign(Object.assign({}, firstMessage), { metamaskId: messageId }));
+        const message = controller.getMessage(messageId);
+        expect(messageParams).toStrictEqual(firstMessage);
+        if (!message) {
+            throw new Error('"message" is falsy');
+        }
+        expect(message.status).toStrictEqual('approved');
+    }));
+    it('should set message status signed', () => {
+        const controller = new MessageManager_1.MessageManager();
+        const firstMessage = { from: 'foo', data: '0x123' };
+        const rawSig = '0x5f7a0';
+        const messageId = controller.addUnapprovedMessage(firstMessage);
+        controller.setMessageStatusSigned(messageId, rawSig);
+        const message = controller.getMessage(messageId);
+        if (!message) {
+            throw new Error('"message" is falsy');
+        }
+        expect(message.rawSig).toStrictEqual(rawSig);
+        expect(message.status).toStrictEqual('signed');
+    });
+    it('should reject message', () => {
+        const controller = new MessageManager_1.MessageManager();
+        const firstMessage = { from: 'foo', data: '0x123' };
+        const messageId = controller.addUnapprovedMessage(firstMessage);
+        controller.rejectMessage(messageId);
+        const message = controller.getMessage(messageId);
+        if (!message) {
+            throw new Error('"message" is falsy');
+        }
+        expect(message.status).toStrictEqual('rejected');
+    });
+});
+//# sourceMappingURL=MessageManager.test%20copy.js.map
\ No newline at end of file
diff --git a/dist/MessageManager.test copy.js.map b/dist/MessageManager.test copy.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..f2d0dfd01d6f8ecc82c6cac7e759a810c0aabfdb
--- /dev/null
+++ b/dist/MessageManager.test copy.js.map	
@@ -0,0 +1 @@
+{"version":3,"file":"MessageManager.test copy.js","sourceRoot":"","sources":["../src/MessageManager.test copy.ts"],"names":[],"mappings":"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","sourcesContent":["import { MessageManager } from './MessageManager';\n\ndescribe('PersonalMessageManager', () => {\n  it('should set default state', () => {\n    const controller = new MessageManager();\n    expect(controller.state).toStrictEqual({\n      unapprovedMessages: {},\n      unapprovedMessagesCount: 0,\n    });\n  });\n\n  it('should set default config', () => {\n    const controller = new MessageManager();\n    expect(controller.config).toStrictEqual({});\n  });\n\n  it('should add a valid message', async () => {\n    const controller = new MessageManager();\n    const messageId = '1';\n    const from = '0x0123';\n    const messageData = '0x123';\n    const messageTime = Date.now();\n    const messageStatus = 'unapproved';\n    const messageType = 'eth_sign';\n    controller.addMessage({\n      id: messageId,\n      messageParams: {\n        data: messageData,\n        from,\n      },\n      status: messageStatus,\n      time: messageTime,\n      type: messageType,\n    });\n    const message = controller.getMessage(messageId);\n    if (!message) {\n      throw new Error('\"message\" is falsy');\n    }\n    expect(message.id).toBe(messageId);\n    expect(message.messageParams.from).toBe(from);\n    expect(message.messageParams.data).toBe(messageData);\n    expect(message.time).toBe(messageTime);\n    expect(message.status).toBe(messageStatus);\n    expect(message.type).toBe(messageType);\n  });\n\n  it('should reject a message', async () => {\n    const controller = new MessageManager();\n    const from = '0xc38bf1ad06ef69f0c04e29dbeb4152b4175f0a8d';\n    const data = '0x879a053d4800c6354e76c7985a865d2922c82fb5b';\n    const result = controller.addUnapprovedMessageAsync({\n      data,\n      from,\n    });\n    const unapprovedMessages = controller.getUnapprovedMessages();\n    const keys = Object.keys(unapprovedMessages);\n    controller.hub.once(`${keys[0]}:finished`, () => {\n      expect(unapprovedMessages[keys[0]].messageParams.from).toBe(from);\n      expect(unapprovedMessages[keys[0]].status).toBe('rejected');\n    });\n    controller.rejectMessage(keys[0]);\n    await expect(result).rejects.toThrow('User denied message signature');\n  });\n\n  it('should sign a message', async () => {\n    const controller = new MessageManager();\n    const from = '0xc38bf1ad06ef69f0c04e29dbeb4152b4175f0a8d';\n    const data = '0x879a053d4800c6354e76c7985a865d2922c82fb5b';\n    const rawSig = '0x5f7a0';\n    const result = controller.addUnapprovedMessageAsync({\n      data,\n      from,\n    });\n    const unapprovedMessages = controller.getUnapprovedMessages();\n    const keys = Object.keys(unapprovedMessages);\n    controller.hub.once(`${keys[0]}:finished`, () => {\n      expect(unapprovedMessages[keys[0]].messageParams.from).toBe(from);\n      expect(unapprovedMessages[keys[0]].status).toBe('signed');\n    });\n    controller.setMessageStatusSigned(keys[0], rawSig);\n    const sig = await result;\n    expect(sig).toBe(rawSig);\n  });\n\n  it('should throw when unapproved finishes', async () => {\n    const controller = new MessageManager();\n    const from = '0xc38bf1ad06ef69f0c04e29dbeb4152b4175f0a8d';\n    const data = '0x879a053d4800c6354e76c7985a865d2922c82fb5b';\n    const result = controller.addUnapprovedMessageAsync({\n      data,\n      from,\n    });\n    const unapprovedMessages = controller.getUnapprovedMessages();\n    const keys = Object.keys(unapprovedMessages);\n    controller.hub.emit(`${keys[0]}:finished`, unapprovedMessages[keys[0]]);\n    await expect(result).rejects.toThrow('Unknown problem');\n  });\n\n  it('should add a valid unapproved message', async () => {\n    const controller = new MessageManager();\n    const messageStatus = 'unapproved';\n    const messageType = 'eth_sign';\n    const messageParams = {\n      data: '0x123',\n      from: '0xfoO',\n    };\n    const originalRequest = { origin: 'origin' };\n    const messageId = controller.addUnapprovedMessage(\n      messageParams,\n      originalRequest,\n    );\n    expect(messageId).not.toBeUndefined();\n    const message = controller.getMessage(messageId);\n    if (!message) {\n      throw new Error('\"message\" is falsy');\n    }\n    expect(message.messageParams.from).toBe(messageParams.from);\n    expect(message.messageParams.data).toBe(messageParams.data);\n    expect(message.time).not.toBeUndefined();\n    expect(message.status).toBe(messageStatus);\n    expect(message.type).toBe(messageType);\n  });\n\n  it('should throw when adding invalid message', async () => {\n    const from = 'foo';\n    const messageData = '0x123';\n    const controller = new MessageManager();\n    await expect(\n      controller.addUnapprovedMessageAsync({\n        data: messageData,\n        from,\n      }),\n    ).rejects.toThrow('Invalid \"from\" address:');\n  });\n\n  it('should get correct unapproved messages', () => {\n    const firstMessage = {\n      id: '1',\n      messageParams: { from: '0x1', data: '0x123' },\n      status: 'unapproved',\n      time: 123,\n      type: 'eth_sign',\n    };\n    const secondMessage = {\n      id: '2',\n      messageParams: { from: '0x1', data: '0x321' },\n      status: 'unapproved',\n      time: 123,\n      type: 'eth_sign',\n    };\n    const controller = new MessageManager();\n    controller.addMessage(firstMessage);\n    controller.addMessage(secondMessage);\n    expect(controller.getUnapprovedMessagesCount()).toStrictEqual(2);\n    expect(controller.getUnapprovedMessages()).toStrictEqual({\n      [firstMessage.id]: firstMessage,\n      [secondMessage.id]: secondMessage,\n    });\n  });\n\n  it('should approve message', async () => {\n    const controller = new MessageManager();\n    const firstMessage = { from: 'foo', data: '0x123' };\n    const messageId = controller.addUnapprovedMessage(firstMessage);\n    const messageParams = await controller.approveMessage({\n      ...firstMessage,\n      metamaskId: messageId,\n    });\n    const message = controller.getMessage(messageId);\n    expect(messageParams).toStrictEqual(firstMessage);\n    if (!message) {\n      throw new Error('\"message\" is falsy');\n    }\n    expect(message.status).toStrictEqual('approved');\n  });\n\n  it('should set message status signed', () => {\n    const controller = new MessageManager();\n    const firstMessage = { from: 'foo', data: '0x123' };\n    const rawSig = '0x5f7a0';\n    const messageId = controller.addUnapprovedMessage(firstMessage);\n\n    controller.setMessageStatusSigned(messageId, rawSig);\n    const message = controller.getMessage(messageId);\n    if (!message) {\n      throw new Error('\"message\" is falsy');\n    }\n    expect(message.rawSig).toStrictEqual(rawSig);\n    expect(message.status).toStrictEqual('signed');\n  });\n\n  it('should reject message', () => {\n    const controller = new MessageManager();\n    const firstMessage = { from: 'foo', data: '0x123' };\n    const messageId = controller.addUnapprovedMessage(firstMessage);\n    controller.rejectMessage(messageId);\n    const message = controller.getMessage(messageId);\n    if (!message) {\n      throw new Error('\"message\" is falsy');\n    }\n    expect(message.status).toStrictEqual('rejected');\n  });\n});\n"]}
\ No newline at end of file
diff --git a/dist/PersonalMessageManager.d.ts b/dist/PersonalMessageManager.d.ts
index 999eeb36149c36eaa2773b907e01a349f34a038d..5687ecf4768cf95d1b9af5f58ebf540ccd94d1eb 100644
--- a/dist/PersonalMessageManager.d.ts
+++ b/dist/PersonalMessageManager.d.ts
@@ -1,3 +1,4 @@
+import { SIWEMessage } from '@metamask/controller-utils';
 import { AbstractMessageManager, AbstractMessage, AbstractMessageParams, AbstractMessageParamsMetamask, OriginalRequest } from './AbstractMessageManager';
 /**
  * @type Message
@@ -23,6 +24,7 @@ export interface PersonalMessage extends AbstractMessage {
  */
 export interface PersonalMessageParams extends AbstractMessageParams {
     data: string;
+    siwe?: SIWEMessage;
 }
 /**
  * @type MessageParamsMetamask
@@ -64,7 +66,7 @@ export declare class PersonalMessageManager extends AbstractMessageManager<Perso
      * @param req - The original request object possibly containing the origin.
      * @returns The id of the newly created message.
      */
-    addUnapprovedMessage(messageParams: PersonalMessageParams, req?: OriginalRequest): string;
+    addUnapprovedMessage(messageParams: PersonalMessageParams, req?: OriginalRequest): Promise<string>;
     /**
      * Removes the metamaskId property from passed messageParams and returns a promise which
      * resolves the updated messageParams.
diff --git a/dist/PersonalMessageManager.js b/dist/PersonalMessageManager.js
index 036bd3b6aaee53b97a457510ade1190c8dfaf02b..ecb609b89a234d9f5341552d30a97eb14c66b3de 100644
--- a/dist/PersonalMessageManager.js
+++ b/dist/PersonalMessageManager.js
@@ -1,7 +1,17 @@
 "use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.PersonalMessageManager = void 0;
 const uuid_1 = require("uuid");
+const controller_utils_1 = require("@metamask/controller-utils");
 const utils_1 = require("./utils");
 const AbstractMessageManager_1 = require("./AbstractMessageManager");
 /**
@@ -24,18 +34,20 @@ class PersonalMessageManager extends AbstractMessageManager_1.AbstractMessageMan
      * @returns Promise resolving to the raw data of the signature request.
      */
     addUnapprovedMessageAsync(messageParams, req) {
-        return new Promise((resolve, reject) => {
+        return __awaiter(this, void 0, void 0, function* () {
             (0, utils_1.validateSignMessageData)(messageParams);
-            const messageId = this.addUnapprovedMessage(messageParams, req);
-            this.hub.once(`${messageId}:finished`, (data) => {
-                switch (data.status) {
-                    case 'signed':
-                        return resolve(data.rawSig);
-                    case 'rejected':
-                        return reject(new Error('MetaMask Personal Message Signature: User denied message signature.'));
-                    default:
-                        return reject(new Error(`MetaMask Personal Message Signature: Unknown problem: ${JSON.stringify(messageParams)}`));
-                }
+            const messageId = yield this.addUnapprovedMessage(messageParams, req);
+            return new Promise((resolve, reject) => {
+                this.hub.once(`${messageId}:finished`, (data) => {
+                    switch (data.status) {
+                        case 'signed':
+                            return resolve(data.rawSig);
+                        case 'rejected':
+                            return reject(new Error('MetaMask Personal Message Signature: User denied message signature.'));
+                        default:
+                            return reject(new Error(`MetaMask Personal Message Signature: Unknown problem: ${JSON.stringify(messageParams)}`));
+                    }
+                });
             });
         });
     }
@@ -50,21 +62,25 @@ class PersonalMessageManager extends AbstractMessageManager_1.AbstractMessageMan
      * @returns The id of the newly created message.
      */
     addUnapprovedMessage(messageParams, req) {
-        if (req) {
-            messageParams.origin = req.origin;
-        }
-        messageParams.data = (0, utils_1.normalizeMessageData)(messageParams.data);
-        const messageId = (0, uuid_1.v1)();
-        const messageData = {
-            id: messageId,
-            messageParams,
-            status: 'unapproved',
-            time: Date.now(),
-            type: 'personal_sign',
-        };
-        this.addMessage(messageData);
-        this.hub.emit(`unapprovedMessage`, Object.assign(Object.assign({}, messageParams), { metamaskId: messageId }));
-        return messageId;
+        return __awaiter(this, void 0, void 0, function* () {
+            if (req) {
+                messageParams.origin = req.origin;
+            }
+            messageParams.data = (0, utils_1.normalizeMessageData)(messageParams.data);
+            const ethereumSignInData = (0, controller_utils_1.detectSIWE)(messageParams);
+            const finalMsgParams = Object.assign(Object.assign({}, messageParams), { siwe: ethereumSignInData });
+            const messageId = (0, uuid_1.v1)();
+            const messageData = {
+                id: messageId,
+                messageParams: finalMsgParams,
+                status: 'unapproved',
+                time: Date.now(),
+                type: 'personal_sign',
+            };
+            yield this.addMessage(messageData);
+            this.hub.emit(`unapprovedMessage`, Object.assign(Object.assign({}, finalMsgParams), { metamaskId: messageId }));
+            return messageId;
+        });
     }
     /**
      * Removes the metamaskId property from passed messageParams and returns a promise which
diff --git a/dist/PersonalMessageManager.js.map b/dist/PersonalMessageManager.js.map
index 47ff7bc82a358e736719bd185a212b8b9476e32b..647f41cd797ef3c61bbf06d9f71f67993e06fbb2 100644
--- a/dist/PersonalMessageManager.js.map
+++ b/dist/PersonalMessageManager.js.map
@@ -1 +1 @@
-{"version":3,"file":"PersonalMessageManager.js","sourceRoot":"","sources":["../src/PersonalMessageManager.ts"],"names":[],"mappings":";;;AAAA,+BAAoC;AACpC,mCAAwE;AACxE,qEAMkC;AA4ClC;;GAEG;AACH,MAAa,sBAAuB,SAAQ,+CAI3C;IAJD;;QAKE;;WAEG;QACM,SAAI,GAAG,wBAAwB,CAAC;IAuF3C,CAAC;IArFC;;;;;;;OAOG;IACH,yBAAyB,CACvB,aAAoC,EACpC,GAAqB;QAErB,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACrC,IAAA,+BAAuB,EAAC,aAAa,CAAC,CAAC;YACvC,MAAM,SAAS,GAAG,IAAI,CAAC,oBAAoB,CAAC,aAAa,EAAE,GAAG,CAAC,CAAC;YAChE,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,SAAS,WAAW,EAAE,CAAC,IAAqB,EAAE,EAAE;gBAC/D,QAAQ,IAAI,CAAC,MAAM,EAAE;oBACnB,KAAK,QAAQ;wBACX,OAAO,OAAO,CAAC,IAAI,CAAC,MAAgB,CAAC,CAAC;oBACxC,KAAK,UAAU;wBACb,OAAO,MAAM,CACX,IAAI,KAAK,CACP,qEAAqE,CACtE,CACF,CAAC;oBACJ;wBACE,OAAO,MAAM,CACX,IAAI,KAAK,CACP,yDAAyD,IAAI,CAAC,SAAS,CACrE,aAAa,CACd,EAAE,CACJ,CACF,CAAC;iBACL;YACH,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;;;;;;OASG;IACH,oBAAoB,CAClB,aAAoC,EACpC,GAAqB;QAErB,IAAI,GAAG,EAAE;YACP,aAAa,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC;SACnC;QACD,aAAa,CAAC,IAAI,GAAG,IAAA,4BAAoB,EAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QAC9D,MAAM,SAAS,GAAG,IAAA,SAAM,GAAE,CAAC;QAC3B,MAAM,WAAW,GAAoB;YACnC,EAAE,EAAE,SAAS;YACb,aAAa;YACb,MAAM,EAAE,YAAY;YACpB,IAAI,EAAE,IAAI,CAAC,GAAG,EAAE;YAChB,IAAI,EAAE,eAAe;SACtB,CAAC;QACF,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;QAC7B,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,mBAAmB,kCAC5B,aAAa,GACb,EAAE,UAAU,EAAE,SAAS,EAAE,EAC5B,CAAC;QACH,OAAO,SAAS,CAAC;IACnB,CAAC;IAED;;;;;;OAMG;IACH,qBAAqB,CACnB,aAA4C;QAE5C,OAAO,aAAa,CAAC,UAAU,CAAC;QAChC,OAAO,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;IACxC,CAAC;CACF;AA/FD,wDA+FC;AAED,kBAAe,sBAAsB,CAAC","sourcesContent":["import { v1 as random } from 'uuid';\nimport { normalizeMessageData, validateSignMessageData } from './utils';\nimport {\n  AbstractMessageManager,\n  AbstractMessage,\n  AbstractMessageParams,\n  AbstractMessageParamsMetamask,\n  OriginalRequest,\n} from './AbstractMessageManager';\n\n/**\n * @type Message\n *\n * Represents and contains data about a 'personal_sign' type signature request.\n * These are created when a signature for a personal_sign call is requested.\n * @property id - An id to track and identify the message object\n * @property messageParams - The parameters to pass to the personal_sign method once the signature request is approved\n * @property type - The json-prc signing method for which a signature request has been made.\n * A 'Message' which always has a 'personal_sign' type\n * @property rawSig - Raw data of the signature request\n */\nexport interface PersonalMessage extends AbstractMessage {\n  messageParams: PersonalMessageParams;\n}\n\n/**\n * @type PersonalMessageParams\n *\n * Represents the parameters to pass to the personal_sign method once the signature request is approved.\n * @property data - A hex string conversion of the raw buffer data of the signature request\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n */\nexport interface PersonalMessageParams extends AbstractMessageParams {\n  data: string;\n}\n\n/**\n * @type MessageParamsMetamask\n *\n * Represents the parameters to pass to the personal_sign method once the signature request is approved\n * plus data added by MetaMask.\n * @property metamaskId - Added for tracking and identification within MetaMask\n * @property data - A hex string conversion of the raw buffer data of the signature request\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n */\nexport interface PersonalMessageParamsMetamask\n  extends AbstractMessageParamsMetamask {\n  data: string;\n}\n\n/**\n * Controller in charge of managing - storing, adding, removing, updating - Messages.\n */\nexport class PersonalMessageManager extends AbstractMessageManager<\n  PersonalMessage,\n  PersonalMessageParams,\n  PersonalMessageParamsMetamask\n> {\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'PersonalMessageManager';\n\n  /**\n   * Creates a new Message with an 'unapproved' status using the passed messageParams.\n   * this.addMessage is called to add the new Message to this.messages, and to save the unapproved Messages.\n   *\n   * @param messageParams - The params for the personal_sign call to be made after the message is approved.\n   * @param req - The original request object possibly containing the origin.\n   * @returns Promise resolving to the raw data of the signature request.\n   */\n  addUnapprovedMessageAsync(\n    messageParams: PersonalMessageParams,\n    req?: OriginalRequest,\n  ): Promise<string> {\n    return new Promise((resolve, reject) => {\n      validateSignMessageData(messageParams);\n      const messageId = this.addUnapprovedMessage(messageParams, req);\n      this.hub.once(`${messageId}:finished`, (data: PersonalMessage) => {\n        switch (data.status) {\n          case 'signed':\n            return resolve(data.rawSig as string);\n          case 'rejected':\n            return reject(\n              new Error(\n                'MetaMask Personal Message Signature: User denied message signature.',\n              ),\n            );\n          default:\n            return reject(\n              new Error(\n                `MetaMask Personal Message Signature: Unknown problem: ${JSON.stringify(\n                  messageParams,\n                )}`,\n              ),\n            );\n        }\n      });\n    });\n  }\n\n  /**\n   * Creates a new Message with an 'unapproved' status using the passed messageParams.\n   * this.addMessage is called to add the new Message to this.messages, and to save the\n   * unapproved Messages.\n   *\n   * @param messageParams - The params for the personal_sign call to be made after the message\n   * is approved.\n   * @param req - The original request object possibly containing the origin.\n   * @returns The id of the newly created message.\n   */\n  addUnapprovedMessage(\n    messageParams: PersonalMessageParams,\n    req?: OriginalRequest,\n  ) {\n    if (req) {\n      messageParams.origin = req.origin;\n    }\n    messageParams.data = normalizeMessageData(messageParams.data);\n    const messageId = random();\n    const messageData: PersonalMessage = {\n      id: messageId,\n      messageParams,\n      status: 'unapproved',\n      time: Date.now(),\n      type: 'personal_sign',\n    };\n    this.addMessage(messageData);\n    this.hub.emit(`unapprovedMessage`, {\n      ...messageParams,\n      ...{ metamaskId: messageId },\n    });\n    return messageId;\n  }\n\n  /**\n   * Removes the metamaskId property from passed messageParams and returns a promise which\n   * resolves the updated messageParams.\n   *\n   * @param messageParams - The messageParams to modify.\n   * @returns Promise resolving to the messageParams with the metamaskId property removed.\n   */\n  prepMessageForSigning(\n    messageParams: PersonalMessageParamsMetamask,\n  ): Promise<PersonalMessageParams> {\n    delete messageParams.metamaskId;\n    return Promise.resolve(messageParams);\n  }\n}\n\nexport default PersonalMessageManager;\n"]}
\ No newline at end of file
+{"version":3,"file":"PersonalMessageManager.js","sourceRoot":"","sources":["../src/PersonalMessageManager.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,+BAAoC;AACpC,iEAAqE;AACrE,mCAAwE;AACxE,qEAMkC;AA6ClC;;GAEG;AACH,MAAa,sBAAuB,SAAQ,+CAI3C;IAJD;;QAKE;;WAEG;QACM,SAAI,GAAG,wBAAwB,CAAC;IA2F3C,CAAC;IAzFC;;;;;;;OAOG;IACG,yBAAyB,CAC7B,aAAoC,EACpC,GAAqB;;YAErB,IAAA,+BAAuB,EAAC,aAAa,CAAC,CAAC;YACvC,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,oBAAoB,CAAC,aAAa,EAAE,GAAG,CAAC,CAAC;YACtE,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;gBACrC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,SAAS,WAAW,EAAE,CAAC,IAAqB,EAAE,EAAE;oBAC/D,QAAQ,IAAI,CAAC,MAAM,EAAE;wBACnB,KAAK,QAAQ;4BACX,OAAO,OAAO,CAAC,IAAI,CAAC,MAAgB,CAAC,CAAC;wBACxC,KAAK,UAAU;4BACb,OAAO,MAAM,CACX,IAAI,KAAK,CACP,qEAAqE,CACtE,CACF,CAAC;wBACJ;4BACE,OAAO,MAAM,CACX,IAAI,KAAK,CACP,yDAAyD,IAAI,CAAC,SAAS,CACrE,aAAa,CACd,EAAE,CACJ,CACF,CAAC;qBACL;gBACH,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;QACL,CAAC;KAAA;IAED;;;;;;;;;OASG;IACG,oBAAoB,CACxB,aAAoC,EACpC,GAAqB;;YAErB,IAAI,GAAG,EAAE;gBACP,aAAa,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC;aACnC;YACD,aAAa,CAAC,IAAI,GAAG,IAAA,4BAAoB,EAAC,aAAa,CAAC,IAAI,CAAC,CAAC;YAE9D,MAAM,kBAAkB,GAAG,IAAA,6BAAU,EAAC,aAAa,CAAC,CAAC;YACrD,MAAM,cAAc,mCAAQ,aAAa,KAAE,IAAI,EAAE,kBAAkB,GAAE,CAAC;YAEtE,MAAM,SAAS,GAAG,IAAA,SAAM,GAAE,CAAC;YAC3B,MAAM,WAAW,GAAoB;gBACnC,EAAE,EAAE,SAAS;gBACb,aAAa,EAAE,cAAc;gBAC7B,MAAM,EAAE,YAAY;gBACpB,IAAI,EAAE,IAAI,CAAC,GAAG,EAAE;gBAChB,IAAI,EAAE,eAAe;aACtB,CAAC;YACF,MAAM,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;YACnC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,mBAAmB,kCAC5B,cAAc,GACd,EAAE,UAAU,EAAE,SAAS,EAAE,EAC5B,CAAC;YACH,OAAO,SAAS,CAAC;QACnB,CAAC;KAAA;IAED;;;;;;OAMG;IACH,qBAAqB,CACnB,aAA4C;QAE5C,OAAO,aAAa,CAAC,UAAU,CAAC;QAChC,OAAO,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;IACxC,CAAC;CACF;AAnGD,wDAmGC;AAED,kBAAe,sBAAsB,CAAC","sourcesContent":["import { v1 as random } from 'uuid';\nimport { detectSIWE, SIWEMessage } from '@metamask/controller-utils';\nimport { normalizeMessageData, validateSignMessageData } from './utils';\nimport {\n  AbstractMessageManager,\n  AbstractMessage,\n  AbstractMessageParams,\n  AbstractMessageParamsMetamask,\n  OriginalRequest,\n} from './AbstractMessageManager';\n\n/**\n * @type Message\n *\n * Represents and contains data about a 'personal_sign' type signature request.\n * These are created when a signature for a personal_sign call is requested.\n * @property id - An id to track and identify the message object\n * @property messageParams - The parameters to pass to the personal_sign method once the signature request is approved\n * @property type - The json-prc signing method for which a signature request has been made.\n * A 'Message' which always has a 'personal_sign' type\n * @property rawSig - Raw data of the signature request\n */\nexport interface PersonalMessage extends AbstractMessage {\n  messageParams: PersonalMessageParams;\n}\n\n/**\n * @type PersonalMessageParams\n *\n * Represents the parameters to pass to the personal_sign method once the signature request is approved.\n * @property data - A hex string conversion of the raw buffer data of the signature request\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n */\nexport interface PersonalMessageParams extends AbstractMessageParams {\n  data: string;\n  siwe?: SIWEMessage;\n}\n\n/**\n * @type MessageParamsMetamask\n *\n * Represents the parameters to pass to the personal_sign method once the signature request is approved\n * plus data added by MetaMask.\n * @property metamaskId - Added for tracking and identification within MetaMask\n * @property data - A hex string conversion of the raw buffer data of the signature request\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n */\nexport interface PersonalMessageParamsMetamask\n  extends AbstractMessageParamsMetamask {\n  data: string;\n}\n\n/**\n * Controller in charge of managing - storing, adding, removing, updating - Messages.\n */\nexport class PersonalMessageManager extends AbstractMessageManager<\n  PersonalMessage,\n  PersonalMessageParams,\n  PersonalMessageParamsMetamask\n> {\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'PersonalMessageManager';\n\n  /**\n   * Creates a new Message with an 'unapproved' status using the passed messageParams.\n   * this.addMessage is called to add the new Message to this.messages, and to save the unapproved Messages.\n   *\n   * @param messageParams - The params for the personal_sign call to be made after the message is approved.\n   * @param req - The original request object possibly containing the origin.\n   * @returns Promise resolving to the raw data of the signature request.\n   */\n  async addUnapprovedMessageAsync(\n    messageParams: PersonalMessageParams,\n    req?: OriginalRequest,\n  ): Promise<string> {\n    validateSignMessageData(messageParams);\n    const messageId = await this.addUnapprovedMessage(messageParams, req);\n    return new Promise((resolve, reject) => {\n      this.hub.once(`${messageId}:finished`, (data: PersonalMessage) => {\n        switch (data.status) {\n          case 'signed':\n            return resolve(data.rawSig as string);\n          case 'rejected':\n            return reject(\n              new Error(\n                'MetaMask Personal Message Signature: User denied message signature.',\n              ),\n            );\n          default:\n            return reject(\n              new Error(\n                `MetaMask Personal Message Signature: Unknown problem: ${JSON.stringify(\n                  messageParams,\n                )}`,\n              ),\n            );\n        }\n      });\n    });\n  }\n\n  /**\n   * Creates a new Message with an 'unapproved' status using the passed messageParams.\n   * this.addMessage is called to add the new Message to this.messages, and to save the\n   * unapproved Messages.\n   *\n   * @param messageParams - The params for the personal_sign call to be made after the message\n   * is approved.\n   * @param req - The original request object possibly containing the origin.\n   * @returns The id of the newly created message.\n   */\n  async addUnapprovedMessage(\n    messageParams: PersonalMessageParams,\n    req?: OriginalRequest,\n  ): Promise<string> {\n    if (req) {\n      messageParams.origin = req.origin;\n    }\n    messageParams.data = normalizeMessageData(messageParams.data);\n\n    const ethereumSignInData = detectSIWE(messageParams);\n    const finalMsgParams = { ...messageParams, siwe: ethereumSignInData };\n\n    const messageId = random();\n    const messageData: PersonalMessage = {\n      id: messageId,\n      messageParams: finalMsgParams,\n      status: 'unapproved',\n      time: Date.now(),\n      type: 'personal_sign',\n    };\n    await this.addMessage(messageData);\n    this.hub.emit(`unapprovedMessage`, {\n      ...finalMsgParams,\n      ...{ metamaskId: messageId },\n    });\n    return messageId;\n  }\n\n  /**\n   * Removes the metamaskId property from passed messageParams and returns a promise which\n   * resolves the updated messageParams.\n   *\n   * @param messageParams - The messageParams to modify.\n   * @returns Promise resolving to the messageParams with the metamaskId property removed.\n   */\n  prepMessageForSigning(\n    messageParams: PersonalMessageParamsMetamask,\n  ): Promise<PersonalMessageParams> {\n    delete messageParams.metamaskId;\n    return Promise.resolve(messageParams);\n  }\n}\n\nexport default PersonalMessageManager;\n"]}
\ No newline at end of file
diff --git a/dist/TypedMessageManager.d.ts b/dist/TypedMessageManager.d.ts
index a47573c075caca84eeedc34f07b344e245855b2c..cfe4b09c94cca33a98d04b5094e225947348bece 100644
--- a/dist/TypedMessageManager.d.ts
+++ b/dist/TypedMessageManager.d.ts
@@ -80,7 +80,7 @@ export declare class TypedMessageManager extends AbstractMessageManager<TypedMes
      * @param req - The original request object possibly containing the origin.
      * @returns The id of the newly created TypedMessage.
      */
-    addUnapprovedMessage(messageParams: TypedMessageParams, version: string, req?: OriginalRequest): string;
+    addUnapprovedMessage(messageParams: TypedMessageParams, version: string, req?: OriginalRequest): Promise<string>;
     /**
      * Sets a TypedMessage status to 'errored' via a call to this.setMessageStatus.
      *
diff --git a/dist/TypedMessageManager.js b/dist/TypedMessageManager.js
index e4b1aa3d186b1345bb5703a01a564aac543d1b1b..6318bd797b303c0c236c595512c3a13d48530afb 100644
--- a/dist/TypedMessageManager.js
+++ b/dist/TypedMessageManager.js
@@ -1,4 +1,13 @@
 "use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.TypedMessageManager = void 0;
 const uuid_1 = require("uuid");
@@ -25,25 +34,27 @@ class TypedMessageManager extends AbstractMessageManager_1.AbstractMessageManage
      * @returns Promise resolving to the raw data of the signature request.
      */
     addUnapprovedMessageAsync(messageParams, version, req) {
-        return new Promise((resolve, reject) => {
+        return __awaiter(this, void 0, void 0, function* () {
             if (version === 'V1') {
                 (0, utils_1.validateTypedSignMessageDataV1)(messageParams);
             }
             if (version === 'V3') {
                 (0, utils_1.validateTypedSignMessageDataV3)(messageParams);
             }
-            const messageId = this.addUnapprovedMessage(messageParams, version, req);
-            this.hub.once(`${messageId}:finished`, (data) => {
-                switch (data.status) {
-                    case 'signed':
-                        return resolve(data.rawSig);
-                    case 'rejected':
-                        return reject(new Error('MetaMask Typed Message Signature: User denied message signature.'));
-                    case 'errored':
-                        return reject(new Error(`MetaMask Typed Message Signature: ${data.error}`));
-                    default:
-                        return reject(new Error(`MetaMask Typed Message Signature: Unknown problem: ${JSON.stringify(messageParams)}`));
-                }
+            const messageId = yield this.addUnapprovedMessage(messageParams, version, req);
+            return new Promise((resolve, reject) => {
+                this.hub.once(`${messageId}:finished`, (data) => {
+                    switch (data.status) {
+                        case 'signed':
+                            return resolve(data.rawSig);
+                        case 'rejected':
+                            return reject(new Error('MetaMask Typed Message Signature: User denied message signature.'));
+                        case 'errored':
+                            return reject(new Error(`MetaMask Typed Message Signature: ${data.error}`));
+                        default:
+                            return reject(new Error(`MetaMask Typed Message Signature: Unknown problem: ${JSON.stringify(messageParams)}`));
+                    }
+                });
             });
         });
     }
@@ -59,21 +70,23 @@ class TypedMessageManager extends AbstractMessageManager_1.AbstractMessageManage
      * @returns The id of the newly created TypedMessage.
      */
     addUnapprovedMessage(messageParams, version, req) {
-        const messageId = (0, uuid_1.v1)();
-        const messageParamsMetamask = Object.assign(Object.assign({}, messageParams), { metamaskId: messageId, version });
-        if (req) {
-            messageParams.origin = req.origin;
-        }
-        const messageData = {
-            id: messageId,
-            messageParams,
-            status: 'unapproved',
-            time: Date.now(),
-            type: 'eth_signTypedData',
-        };
-        this.addMessage(messageData);
-        this.hub.emit(`unapprovedMessage`, messageParamsMetamask);
-        return messageId;
+        return __awaiter(this, void 0, void 0, function* () {
+            const messageId = (0, uuid_1.v1)();
+            const messageParamsMetamask = Object.assign(Object.assign({}, messageParams), { metamaskId: messageId, version });
+            if (req) {
+                messageParams.origin = req.origin;
+            }
+            const messageData = {
+                id: messageId,
+                messageParams,
+                status: 'unapproved',
+                time: Date.now(),
+                type: 'eth_signTypedData',
+            };
+            this.addMessage(messageData);
+            this.hub.emit(`unapprovedMessage`, messageParamsMetamask);
+            return messageId;
+        });
     }
     /**
      * Sets a TypedMessage status to 'errored' via a call to this.setMessageStatus.
diff --git a/dist/TypedMessageManager.js.map b/dist/TypedMessageManager.js.map
index dd5ba13402b0dfbe38ce0161f4d8f4e2817893c0..6e77bd96bae9070cffc0cb5b53043627513b58ad 100644
--- a/dist/TypedMessageManager.js.map
+++ b/dist/TypedMessageManager.js.map
@@ -1 +1 @@
-{"version":3,"file":"TypedMessageManager.js","sourceRoot":"","sources":["../src/TypedMessageManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { v1 as random } from 'uuid';\nimport {\n  validateTypedSignMessageDataV3,\n  validateTypedSignMessageDataV1,\n} from './utils';\nimport {\n  AbstractMessageManager,\n  AbstractMessage,\n  AbstractMessageParams,\n  AbstractMessageParamsMetamask,\n  OriginalRequest,\n} from './AbstractMessageManager';\n\n/**\n * @type TypedMessage\n *\n * Represents and contains data about an 'eth_signTypedData' type signature request.\n * These are created when a signature for an eth_signTypedData call is requested.\n * @property id - An id to track and identify the message object\n * @property error - Error corresponding to eth_signTypedData error in failure case\n * @property messageParams - The parameters to pass to the eth_signTypedData method once\n * the signature request is approved\n * @property type - The json-prc signing method for which a signature request has been made.\n * A 'TypedMessage' which always has a 'eth_signTypedData' type\n * @property rawSig - Raw data of the signature request\n */\nexport interface TypedMessage extends AbstractMessage {\n  error?: string;\n  messageParams: TypedMessageParams;\n  time: number;\n  status: string;\n  type: string;\n  rawSig?: string;\n}\n\n/**\n * @type TypedMessageParams\n *\n * Represents the parameters to pass to the eth_signTypedData method once the signature request is approved.\n * @property data - A hex string conversion of the raw buffer or an object containing data of the signature\n * request depending on version\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n */\nexport interface TypedMessageParams extends AbstractMessageParams {\n  data: Record<string, unknown>[] | string;\n}\n\n/**\n * @type TypedMessageParamsMetamask\n *\n * Represents the parameters to pass to the eth_signTypedData method once the signature request is approved\n * plus data added by MetaMask.\n * @property metamaskId - Added for tracking and identification within MetaMask\n * @property data - A hex string conversion of the raw buffer or an object containing data of the signature\n * request depending on version\n * @property error? - Added for message errored\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n * @property version - Compatibility version EIP712\n */\nexport interface TypedMessageParamsMetamask\n  extends AbstractMessageParamsMetamask {\n  data: Record<string, unknown>[] | string;\n  metamaskId?: string;\n  error?: string;\n  version?: string;\n}\n\n/**\n * Controller in charge of managing - storing, adding, removing, updating - TypedMessages.\n */\nexport class TypedMessageManager extends AbstractMessageManager<\n  TypedMessage,\n  TypedMessageParams,\n  TypedMessageParamsMetamask\n> {\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TypedMessageManager';\n\n  /**\n   * Creates a new TypedMessage with an 'unapproved' status using the passed messageParams.\n   * this.addMessage is called to add the new TypedMessage to this.messages, and to save the unapproved TypedMessages.\n   *\n   * @param messageParams - The params for the eth_signTypedData call to be made after the message is approved.\n   * @param version - Compatibility version EIP712.\n   * @param req - The original request object possibly containing the origin.\n   * @returns Promise resolving to the raw data of the signature request.\n   */\n  addUnapprovedMessageAsync(\n    messageParams: TypedMessageParams,\n    version: string,\n    req?: OriginalRequest,\n  ): Promise<string> {\n    return new Promise((resolve, reject) => {\n      if (version === 'V1') {\n        validateTypedSignMessageDataV1(messageParams);\n      }\n\n      if (version === 'V3') {\n        validateTypedSignMessageDataV3(messageParams);\n      }\n      const messageId = this.addUnapprovedMessage(messageParams, version, req);\n      this.hub.once(`${messageId}:finished`, (data: TypedMessage) => {\n        switch (data.status) {\n          case 'signed':\n            return resolve(data.rawSig as string);\n          case 'rejected':\n            return reject(\n              new Error(\n                'MetaMask Typed Message Signature: User denied message signature.',\n              ),\n            );\n          case 'errored':\n            return reject(\n              new Error(`MetaMask Typed Message Signature: ${data.error}`),\n            );\n          default:\n            return reject(\n              new Error(\n                `MetaMask Typed Message Signature: Unknown problem: ${JSON.stringify(\n                  messageParams,\n                )}`,\n              ),\n            );\n        }\n      });\n    });\n  }\n\n  /**\n   * Creates a new TypedMessage with an 'unapproved' status using the passed messageParams.\n   * this.addMessage is called to add the new TypedMessage to this.messages, and to save the\n   * unapproved TypedMessages.\n   *\n   * @param messageParams - The params for the 'eth_signTypedData' call to be made after the message\n   * is approved.\n   * @param version - Compatibility version EIP712.\n   * @param req - The original request object possibly containing the origin.\n   * @returns The id of the newly created TypedMessage.\n   */\n  addUnapprovedMessage(\n    messageParams: TypedMessageParams,\n    version: string,\n    req?: OriginalRequest,\n  ) {\n    const messageId = random();\n    const messageParamsMetamask = {\n      ...messageParams,\n      metamaskId: messageId,\n      version,\n    };\n    if (req) {\n      messageParams.origin = req.origin;\n    }\n    const messageData: TypedMessage = {\n      id: messageId,\n      messageParams,\n      status: 'unapproved',\n      time: Date.now(),\n      type: 'eth_signTypedData',\n    };\n    this.addMessage(messageData);\n    this.hub.emit(`unapprovedMessage`, messageParamsMetamask);\n    return messageId;\n  }\n\n  /**\n   * Sets a TypedMessage status to 'errored' via a call to this.setMessageStatus.\n   *\n   * @param messageId - The id of the TypedMessage to error.\n   * @param error - The error to be included in TypedMessage.\n   */\n  setMessageStatusErrored(messageId: string, error: string) {\n    const message = this.getMessage(messageId);\n    /* istanbul ignore if */\n    if (!message) {\n      return;\n    }\n    message.error = error;\n    this.updateMessage(message);\n    this.setMessageStatus(messageId, 'errored');\n  }\n\n  /**\n   * Removes the metamaskId and version properties from passed messageParams and returns a promise which\n   * resolves the updated messageParams.\n   *\n   * @param messageParams - The messageParams to modify.\n   * @returns Promise resolving to the messageParams with the metamaskId and version properties removed.\n   */\n  prepMessageForSigning(\n    messageParams: TypedMessageParamsMetamask,\n  ): Promise<TypedMessageParams> {\n    delete messageParams.metamaskId;\n    delete messageParams.version;\n    return Promise.resolve(messageParams);\n  }\n}\n\nexport default TypedMessageManager;\n"]}
\ No newline at end of file
+{"version":3,"file":"TypedMessageManager.js","sourceRoot":"","sources":["../src/TypedMessageManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { v1 as random } from 'uuid';\nimport {\n  validateTypedSignMessageDataV3,\n  validateTypedSignMessageDataV1,\n} from './utils';\nimport {\n  AbstractMessageManager,\n  AbstractMessage,\n  AbstractMessageParams,\n  AbstractMessageParamsMetamask,\n  OriginalRequest,\n} from './AbstractMessageManager';\n\n/**\n * @type TypedMessage\n *\n * Represents and contains data about an 'eth_signTypedData' type signature request.\n * These are created when a signature for an eth_signTypedData call is requested.\n * @property id - An id to track and identify the message object\n * @property error - Error corresponding to eth_signTypedData error in failure case\n * @property messageParams - The parameters to pass to the eth_signTypedData method once\n * the signature request is approved\n * @property type - The json-prc signing method for which a signature request has been made.\n * A 'TypedMessage' which always has a 'eth_signTypedData' type\n * @property rawSig - Raw data of the signature request\n */\nexport interface TypedMessage extends AbstractMessage {\n  error?: string;\n  messageParams: TypedMessageParams;\n  time: number;\n  status: string;\n  type: string;\n  rawSig?: string;\n}\n\n/**\n * @type TypedMessageParams\n *\n * Represents the parameters to pass to the eth_signTypedData method once the signature request is approved.\n * @property data - A hex string conversion of the raw buffer or an object containing data of the signature\n * request depending on version\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n */\nexport interface TypedMessageParams extends AbstractMessageParams {\n  data: Record<string, unknown>[] | string;\n}\n\n/**\n * @type TypedMessageParamsMetamask\n *\n * Represents the parameters to pass to the eth_signTypedData method once the signature request is approved\n * plus data added by MetaMask.\n * @property metamaskId - Added for tracking and identification within MetaMask\n * @property data - A hex string conversion of the raw buffer or an object containing data of the signature\n * request depending on version\n * @property error? - Added for message errored\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n * @property version - Compatibility version EIP712\n */\nexport interface TypedMessageParamsMetamask\n  extends AbstractMessageParamsMetamask {\n  data: Record<string, unknown>[] | string;\n  metamaskId?: string;\n  error?: string;\n  version?: string;\n}\n\n/**\n * Controller in charge of managing - storing, adding, removing, updating - TypedMessages.\n */\nexport class TypedMessageManager extends AbstractMessageManager<\n  TypedMessage,\n  TypedMessageParams,\n  TypedMessageParamsMetamask\n> {\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TypedMessageManager';\n\n  /**\n   * Creates a new TypedMessage with an 'unapproved' status using the passed messageParams.\n   * this.addMessage is called to add the new TypedMessage to this.messages, and to save the unapproved TypedMessages.\n   *\n   * @param messageParams - The params for the eth_signTypedData call to be made after the message is approved.\n   * @param version - Compatibility version EIP712.\n   * @param req - The original request object possibly containing the origin.\n   * @returns Promise resolving to the raw data of the signature request.\n   */\n  async addUnapprovedMessageAsync(\n    messageParams: TypedMessageParams,\n    version: string,\n    req?: OriginalRequest,\n  ): Promise<string> {\n    if (version === 'V1') {\n      validateTypedSignMessageDataV1(messageParams);\n    }\n\n    if (version === 'V3') {\n      validateTypedSignMessageDataV3(messageParams);\n    }\n    const messageId = await this.addUnapprovedMessage(\n      messageParams,\n      version,\n      req,\n    );\n    return new Promise((resolve, reject) => {\n      this.hub.once(`${messageId}:finished`, (data: TypedMessage) => {\n        switch (data.status) {\n          case 'signed':\n            return resolve(data.rawSig as string);\n          case 'rejected':\n            return reject(\n              new Error(\n                'MetaMask Typed Message Signature: User denied message signature.',\n              ),\n            );\n          case 'errored':\n            return reject(\n              new Error(`MetaMask Typed Message Signature: ${data.error}`),\n            );\n          default:\n            return reject(\n              new Error(\n                `MetaMask Typed Message Signature: Unknown problem: ${JSON.stringify(\n                  messageParams,\n                )}`,\n              ),\n            );\n        }\n      });\n    });\n  }\n\n  /**\n   * Creates a new TypedMessage with an 'unapproved' status using the passed messageParams.\n   * this.addMessage is called to add the new TypedMessage to this.messages, and to save the\n   * unapproved TypedMessages.\n   *\n   * @param messageParams - The params for the 'eth_signTypedData' call to be made after the message\n   * is approved.\n   * @param version - Compatibility version EIP712.\n   * @param req - The original request object possibly containing the origin.\n   * @returns The id of the newly created TypedMessage.\n   */\n  async addUnapprovedMessage(\n    messageParams: TypedMessageParams,\n    version: string,\n    req?: OriginalRequest,\n  ): Promise<string> {\n    const messageId = random();\n    const messageParamsMetamask = {\n      ...messageParams,\n      metamaskId: messageId,\n      version,\n    };\n    if (req) {\n      messageParams.origin = req.origin;\n    }\n    const messageData: TypedMessage = {\n      id: messageId,\n      messageParams,\n      status: 'unapproved',\n      time: Date.now(),\n      type: 'eth_signTypedData',\n    };\n    this.addMessage(messageData);\n    this.hub.emit(`unapprovedMessage`, messageParamsMetamask);\n    return messageId;\n  }\n\n  /**\n   * Sets a TypedMessage status to 'errored' via a call to this.setMessageStatus.\n   *\n   * @param messageId - The id of the TypedMessage to error.\n   * @param error - The error to be included in TypedMessage.\n   */\n  setMessageStatusErrored(messageId: string, error: string) {\n    const message = this.getMessage(messageId);\n    /* istanbul ignore if */\n    if (!message) {\n      return;\n    }\n    message.error = error;\n    this.updateMessage(message);\n    this.setMessageStatus(messageId, 'errored');\n  }\n\n  /**\n   * Removes the metamaskId and version properties from passed messageParams and returns a promise which\n   * resolves the updated messageParams.\n   *\n   * @param messageParams - The messageParams to modify.\n   * @returns Promise resolving to the messageParams with the metamaskId and version properties removed.\n   */\n  prepMessageForSigning(\n    messageParams: TypedMessageParamsMetamask,\n  ): Promise<TypedMessageParams> {\n    delete messageParams.metamaskId;\n    delete messageParams.version;\n    return Promise.resolve(messageParams);\n  }\n}\n\nexport default TypedMessageManager;\n"]}
\ No newline at end of file
diff --git a/dist/index.d.ts b/dist/index.d.ts
index 239569e41c9b495d3c96b1551b147692ac3540e2..f46db1b31ede62d9a3f9ed3122961f855d6553a6 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -1,3 +1,4 @@
 export * from './MessageManager';
 export * from './PersonalMessageManager';
 export * from './TypedMessageManager';
+export * from './EncryptionPublicKeyManager';
diff --git a/dist/index.js b/dist/index.js
index 8d75777f20c195b18edb2f0694265d308dc92b8e..1eb9f8c52c013f11d4937e3d2c168c37bc89aa82 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -17,4 +17,5 @@ Object.defineProperty(exports, "__esModule", { value: true });
 __exportStar(require("./MessageManager"), exports);
 __exportStar(require("./PersonalMessageManager"), exports);
 __exportStar(require("./TypedMessageManager"), exports);
+__exportStar(require("./EncryptionPublicKeyManager"), exports);
 //# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/dist/index.js.map b/dist/index.js.map
index 493206392ac232790a0ff6a32ea0e961f6138d45..0f765579ee92feec8a7ab79d05407bbb5f3f4dee 100644
--- a/dist/index.js.map
+++ b/dist/index.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,mDAAiC;AACjC,2DAAyC;AACzC,wDAAsC","sourcesContent":["export * from './MessageManager';\nexport * from './PersonalMessageManager';\nexport * from './TypedMessageManager';\n"]}
\ No newline at end of file
+{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,mDAAiC;AACjC,2DAAyC;AACzC,wDAAsC;AACtC,+DAA6C","sourcesContent":["export * from './MessageManager';\nexport * from './PersonalMessageManager';\nexport * from './TypedMessageManager';\nexport * from './EncryptionPublicKeyManager';\n"]}
\ No newline at end of file
diff --git a/dist/utils.d.ts b/dist/utils.d.ts
index 7ff922ba330d3eb2842b4ea853c31960b632a938..36eb86b5f6c49ab995864b9c22ca015e2c1ea376 100644
--- a/dist/utils.d.ts
+++ b/dist/utils.d.ts
@@ -1,6 +1,7 @@
 import { MessageParams } from './MessageManager';
 import { PersonalMessageParams } from './PersonalMessageManager';
 import { TypedMessageParams } from './TypedMessageManager';
+import { EncryptionPublicKeyParams } from './EncryptionPublicKeyManager';
 /**
  * A helper function that converts rawmessageData buffer data to a hex, or just returns the data if
  * it is already formatted as a hex.
@@ -30,3 +31,10 @@ export declare function validateTypedSignMessageDataV1(messageData: TypedMessage
  * @param messageData - TypedMessageParams object to validate.
  */
 export declare function validateTypedSignMessageDataV3(messageData: TypedMessageParams): void;
+/**
+ * Validates messageData for the eth_getEncryptionPublicKey message and throws in
+ * the event of any validation error.
+ *
+ * @param messageData - address string to validate.
+ */
+export declare function validateEncryptionPublicKeyMessageData(messageData: EncryptionPublicKeyParams): void;
diff --git a/dist/utils.js b/dist/utils.js
index b4f9d5804339bbf70bc68d92a875e203f19b73ae..3d80cd8353dfdbeac2e93b706bd382980ea7cca2 100644
--- a/dist/utils.js
+++ b/dist/utils.js
@@ -1,6 +1,6 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.validateTypedSignMessageDataV3 = exports.validateTypedSignMessageDataV1 = exports.validateSignMessageData = exports.normalizeMessageData = void 0;
+exports.validateEncryptionPublicKeyMessageData = exports.validateTypedSignMessageDataV3 = exports.validateTypedSignMessageDataV1 = exports.validateSignMessageData = exports.normalizeMessageData = void 0;
 const ethereumjs_util_1 = require("ethereumjs-util");
 const eth_sig_util_1 = require("eth-sig-util");
 const jsonschema_1 = require("jsonschema");
@@ -94,4 +94,17 @@ function validateTypedSignMessageDataV3(messageData) {
     }
 }
 exports.validateTypedSignMessageDataV3 = validateTypedSignMessageDataV3;
+/**
+ * Validates messageData for the eth_getEncryptionPublicKey message and throws in
+ * the event of any validation error.
+ *
+ * @param messageData - address string to validate.
+ */
+function validateEncryptionPublicKeyMessageData(messageData) {
+    const { from } = messageData;
+    if (!from || typeof from !== 'string' || !(0, controller_utils_1.isValidHexAddress)(from)) {
+        throw new Error(`Invalid "from" address: ${from} must be a valid string.`);
+    }
+}
+exports.validateEncryptionPublicKeyMessageData = validateEncryptionPublicKeyMessageData;
 //# sourceMappingURL=utils.js.map
\ No newline at end of file
diff --git a/dist/utils.js.map b/dist/utils.js.map
index e397b664d87243ea85c204c29374d930d3c4386e..885a3ff0c086531ab9fc1d9e06fa207152d320b0 100644
--- a/dist/utils.js.map
+++ b/dist/utils.js.map
@@ -1 +1 @@
-{"version":3,"file":"utils.js","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { addHexPrefix, bufferToHex, stripHexPrefix } from 'ethereumjs-util';\nimport { TYPED_MESSAGE_SCHEMA, typedSignatureHash } from 'eth-sig-util';\nimport { validate } from 'jsonschema';\nimport { isValidHexAddress } from '@metamask/controller-utils';\nimport { MessageParams } from './MessageManager';\nimport { PersonalMessageParams } from './PersonalMessageManager';\nimport { TypedMessageParams } from './TypedMessageManager';\n\nconst hexRe = /^[0-9A-Fa-f]+$/gu;\n\n/**\n * A helper function that converts rawmessageData buffer data to a hex, or just returns the data if\n * it is already formatted as a hex.\n *\n * @param data - The buffer data to convert to a hex.\n * @returns A hex string conversion of the buffer data.\n */\nexport function normalizeMessageData(data: string) {\n  try {\n    const stripped = stripHexPrefix(data);\n    if (stripped.match(hexRe)) {\n      return addHexPrefix(stripped);\n    }\n  } catch (e) {\n    /* istanbul ignore next */\n  }\n  return bufferToHex(Buffer.from(data, 'utf8'));\n}\n\n/**\n * Validates a PersonalMessageParams and MessageParams objects for required properties and throws in\n * the event of any validation error.\n *\n * @param messageData - PersonalMessageParams object to validate.\n */\nexport function validateSignMessageData(\n  messageData: PersonalMessageParams | MessageParams,\n) {\n  const { from, data } = messageData;\n  if (!from || typeof from !== 'string' || !isValidHexAddress(from)) {\n    throw new Error(`Invalid \"from\" address: ${from} must be a valid string.`);\n  }\n\n  if (!data || typeof data !== 'string') {\n    throw new Error(`Invalid message \"data\": ${data} must be a valid string.`);\n  }\n}\n\n/**\n * Validates a TypedMessageParams object for required properties and throws in\n * the event of any validation error for eth_signTypedMessage_V1.\n *\n * @param messageData - TypedMessageParams object to validate.\n */\nexport function validateTypedSignMessageDataV1(\n  messageData: TypedMessageParams,\n) {\n  if (\n    !messageData.from ||\n    typeof messageData.from !== 'string' ||\n    !isValidHexAddress(messageData.from)\n  ) {\n    throw new Error(\n      `Invalid \"from\" address: ${messageData.from} must be a valid string.`,\n    );\n  }\n\n  if (!messageData.data || !Array.isArray(messageData.data)) {\n    throw new Error(\n      `Invalid message \"data\": ${messageData.data} must be a valid array.`,\n    );\n  }\n\n  try {\n    // typedSignatureHash will throw if the data is invalid.\n    typedSignatureHash(messageData.data as any);\n  } catch (e) {\n    throw new Error(`Expected EIP712 typed data.`);\n  }\n}\n\n/**\n * Validates a TypedMessageParams object for required properties and throws in\n * the event of any validation error for eth_signTypedMessage_V3.\n *\n * @param messageData - TypedMessageParams object to validate.\n */\nexport function validateTypedSignMessageDataV3(\n  messageData: TypedMessageParams,\n) {\n  if (\n    !messageData.from ||\n    typeof messageData.from !== 'string' ||\n    !isValidHexAddress(messageData.from)\n  ) {\n    throw new Error(\n      `Invalid \"from\" address: ${messageData.from} must be a valid string.`,\n    );\n  }\n\n  if (!messageData.data || typeof messageData.data !== 'string') {\n    throw new Error(\n      `Invalid message \"data\": ${messageData.data} must be a valid array.`,\n    );\n  }\n  let data;\n  try {\n    data = JSON.parse(messageData.data);\n  } catch (e) {\n    throw new Error('Data must be passed as a valid JSON string.');\n  }\n  const validation = validate(data, TYPED_MESSAGE_SCHEMA);\n  if (validation.errors.length > 0) {\n    throw new Error(\n      'Data must conform to EIP-712 schema. See https://git.io/fNtcx.',\n    );\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"utils.js","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { addHexPrefix, bufferToHex, stripHexPrefix } from 'ethereumjs-util';\nimport { TYPED_MESSAGE_SCHEMA, typedSignatureHash } from 'eth-sig-util';\nimport { validate } from 'jsonschema';\nimport { isValidHexAddress } from '@metamask/controller-utils';\nimport { MessageParams } from './MessageManager';\nimport { PersonalMessageParams } from './PersonalMessageManager';\nimport { TypedMessageParams } from './TypedMessageManager';\nimport { EncryptionPublicKeyParams } from './EncryptionPublicKeyManager';\n\nconst hexRe = /^[0-9A-Fa-f]+$/gu;\n\n/**\n * A helper function that converts rawmessageData buffer data to a hex, or just returns the data if\n * it is already formatted as a hex.\n *\n * @param data - The buffer data to convert to a hex.\n * @returns A hex string conversion of the buffer data.\n */\nexport function normalizeMessageData(data: string) {\n  try {\n    const stripped = stripHexPrefix(data);\n    if (stripped.match(hexRe)) {\n      return addHexPrefix(stripped);\n    }\n  } catch (e) {\n    /* istanbul ignore next */\n  }\n  return bufferToHex(Buffer.from(data, 'utf8'));\n}\n\n/**\n * Validates a PersonalMessageParams and MessageParams objects for required properties and throws in\n * the event of any validation error.\n *\n * @param messageData - PersonalMessageParams object to validate.\n */\nexport function validateSignMessageData(\n  messageData: PersonalMessageParams | MessageParams,\n) {\n  const { from, data } = messageData;\n  if (!from || typeof from !== 'string' || !isValidHexAddress(from)) {\n    throw new Error(`Invalid \"from\" address: ${from} must be a valid string.`);\n  }\n\n  if (!data || typeof data !== 'string') {\n    throw new Error(`Invalid message \"data\": ${data} must be a valid string.`);\n  }\n}\n\n/**\n * Validates a TypedMessageParams object for required properties and throws in\n * the event of any validation error for eth_signTypedMessage_V1.\n *\n * @param messageData - TypedMessageParams object to validate.\n */\nexport function validateTypedSignMessageDataV1(\n  messageData: TypedMessageParams,\n) {\n  if (\n    !messageData.from ||\n    typeof messageData.from !== 'string' ||\n    !isValidHexAddress(messageData.from)\n  ) {\n    throw new Error(\n      `Invalid \"from\" address: ${messageData.from} must be a valid string.`,\n    );\n  }\n\n  if (!messageData.data || !Array.isArray(messageData.data)) {\n    throw new Error(\n      `Invalid message \"data\": ${messageData.data} must be a valid array.`,\n    );\n  }\n\n  try {\n    // typedSignatureHash will throw if the data is invalid.\n    typedSignatureHash(messageData.data as any);\n  } catch (e) {\n    throw new Error(`Expected EIP712 typed data.`);\n  }\n}\n\n/**\n * Validates a TypedMessageParams object for required properties and throws in\n * the event of any validation error for eth_signTypedMessage_V3.\n *\n * @param messageData - TypedMessageParams object to validate.\n */\nexport function validateTypedSignMessageDataV3(\n  messageData: TypedMessageParams,\n) {\n  if (\n    !messageData.from ||\n    typeof messageData.from !== 'string' ||\n    !isValidHexAddress(messageData.from)\n  ) {\n    throw new Error(\n      `Invalid \"from\" address: ${messageData.from} must be a valid string.`,\n    );\n  }\n\n  if (!messageData.data || typeof messageData.data !== 'string') {\n    throw new Error(\n      `Invalid message \"data\": ${messageData.data} must be a valid array.`,\n    );\n  }\n  let data;\n  try {\n    data = JSON.parse(messageData.data);\n  } catch (e) {\n    throw new Error('Data must be passed as a valid JSON string.');\n  }\n  const validation = validate(data, TYPED_MESSAGE_SCHEMA);\n  if (validation.errors.length > 0) {\n    throw new Error(\n      'Data must conform to EIP-712 schema. See https://git.io/fNtcx.',\n    );\n  }\n}\n\n/**\n * Validates messageData for the eth_getEncryptionPublicKey message and throws in\n * the event of any validation error.\n *\n * @param messageData - address string to validate.\n */\nexport function validateEncryptionPublicKeyMessageData(\n  messageData: EncryptionPublicKeyParams,\n) {\n  const { from } = messageData;\n  if (!from || typeof from !== 'string' || !isValidHexAddress(from)) {\n    throw new Error(`Invalid \"from\" address: ${from} must be a valid string.`);\n  }\n}\n"]}
\ No newline at end of file
