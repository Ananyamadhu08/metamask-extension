diff --git a/dist/index.d.ts b/dist/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8498ab8366bd318cbae885539aab415d110192a4
--- /dev/null
+++ b/dist/index.d.ts
@@ -0,0 +1,3 @@
+export * from './trezor-keyring';
+export * from './trezor-bridge';
+export * from './trezor-connect-bridge';
diff --git a/dist/index.js b/dist/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..7da3714a6d57ecffdb11affafbed253c20ad86f5
--- /dev/null
+++ b/dist/index.js
@@ -0,0 +1,20 @@
+"use strict";
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __exportStar = (this && this.__exportStar) || function(m, exports) {
+    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+__exportStar(require("./trezor-keyring"), exports);
+__exportStar(require("./trezor-bridge"), exports);
+__exportStar(require("./trezor-connect-bridge"), exports);
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/dist/index.js.map b/dist/index.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..5a95e7037d483e094815528f74cd653431808f86
--- /dev/null
+++ b/dist/index.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,mDAAiC;AACjC,kDAAgC;AAChC,0DAAwC","sourcesContent":["export * from './trezor-keyring';\nexport * from './trezor-bridge';\nexport * from './trezor-connect-bridge';\n"]}
\ No newline at end of file
diff --git a/dist/trezor-bridge.d.ts b/dist/trezor-bridge.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6300c4072a973ab07ccdbc9ed49426adca985593
--- /dev/null
+++ b/dist/trezor-bridge.d.ts
@@ -0,0 +1,18 @@
+import type { ConnectSettings, EthereumSignedTx, Manifest, PROTO, Response, Params, EthereumSignMessage, EthereumSignTransaction, EthereumSignTypedDataTypes, EthereumSignTypedHash } from '@trezor/connect-web';
+export interface TrezorBridge {
+    model?: string;
+    init(settings: {
+        manifest: Manifest;
+    } & Partial<ConnectSettings>): Promise<void>;
+    dispose(): Promise<void>;
+    getPublicKey(params: {
+        path: string;
+        coin: string;
+    }): Response<{
+        publicKey: string;
+        chainCode: string;
+    }>;
+    ethereumSignTransaction(params: Params<EthereumSignTransaction>): Response<EthereumSignedTx>;
+    ethereumSignMessage(params: Params<EthereumSignMessage>): Response<PROTO.MessageSignature>;
+    ethereumSignTypedData(params: Params<EthereumSignTypedHash<EthereumSignTypedDataTypes>>): Response<PROTO.EthereumTypedDataSignature>;
+}
diff --git a/dist/trezor-bridge.js b/dist/trezor-bridge.js
new file mode 100644
index 0000000000000000000000000000000000000000..2a000fe874f35a3a3cba5e505927de8cd1688c86
--- /dev/null
+++ b/dist/trezor-bridge.js
@@ -0,0 +1,3 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+//# sourceMappingURL=trezor-bridge.js.map
\ No newline at end of file
diff --git a/dist/trezor-bridge.js.map b/dist/trezor-bridge.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..a892d5d9faaf9508250fd7ae1fe00754a9af2581
--- /dev/null
+++ b/dist/trezor-bridge.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"trezor-bridge.js","sourceRoot":"","sources":["../src/trezor-bridge.ts"],"names":[],"mappings":"","sourcesContent":["import type {\n  ConnectSettings,\n  EthereumSignedTx,\n  Manifest,\n  PROTO,\n  Response,\n  Params,\n  EthereumSignMessage,\n  EthereumSignTransaction,\n  EthereumSignTypedDataTypes,\n  EthereumSignTypedHash,\n} from '@trezor/connect-web';\n\nexport interface TrezorBridge {\n  model?: string;\n\n  init(\n    settings: {\n      manifest: Manifest;\n    } & Partial<ConnectSettings>,\n  ): Promise<void>;\n\n  dispose(): Promise<void>;\n\n  getPublicKey(params: {\n    path: string;\n    coin: string;\n  }): Response<{ publicKey: string; chainCode: string }>;\n\n  ethereumSignTransaction(\n    params: Params<EthereumSignTransaction>,\n  ): Response<EthereumSignedTx>;\n\n  ethereumSignMessage(\n    params: Params<EthereumSignMessage>,\n  ): Response<PROTO.MessageSignature>;\n\n  ethereumSignTypedData(\n    params: Params<EthereumSignTypedHash<EthereumSignTypedDataTypes>>,\n  ): Response<PROTO.EthereumTypedDataSignature>;\n}\n"]}
\ No newline at end of file
diff --git a/dist/trezor-connect-bridge.d.ts b/dist/trezor-connect-bridge.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bbd7f4a4a8d5ee43cd96ebe2e4588d50fee28bb3
--- /dev/null
+++ b/dist/trezor-connect-bridge.d.ts
@@ -0,0 +1,16 @@
+import type { Manifest, ConnectSettings, EthereumSignTransaction, Params, EthereumSignMessage, EthereumSignTypedDataTypes, EthereumSignTypedHash } from '@trezor/connect-web';
+import type { TrezorBridge } from './trezor-bridge';
+export declare class TrezorConnectBridge implements TrezorBridge {
+    model?: string;
+    init(settings: {
+        manifest: Manifest;
+    } & Partial<ConnectSettings>): Promise<void>;
+    dispose(): Promise<void>;
+    getPublicKey(params: {
+        path: string;
+        coin: string;
+    }): import("@trezor/connect-web").Response<import("@trezor/connect/lib/types/api/getPublicKey").HDNodeResponse>;
+    ethereumSignTransaction(params: Params<EthereumSignTransaction>): import("@trezor/connect-web").Response<import("@trezor/connect-web").EthereumSignedTx>;
+    ethereumSignMessage(params: Params<EthereumSignMessage>): import("@trezor/connect-web").Response<import("@trezor/transport/lib/types/messages").MessageSignature>;
+    ethereumSignTypedData(params: Params<EthereumSignTypedHash<EthereumSignTypedDataTypes>>): import("@trezor/connect-web").Response<import("@trezor/transport/lib/types/messages").EthereumTypedDataSignature>;
+}
diff --git a/dist/trezor-connect-bridge.js b/dist/trezor-connect-bridge.js
new file mode 100644
index 0000000000000000000000000000000000000000..4b220e68d587e69aa56dca6ae429a6b719da1f05
--- /dev/null
+++ b/dist/trezor-connect-bridge.js
@@ -0,0 +1,60 @@
+"use strict";
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
+    Object.defineProperty(o, "default", { enumerable: true, value: v });
+}) : function(o, v) {
+    o["default"] = v;
+});
+var __importStar = (this && this.__importStar) || function (mod) {
+    if (mod && mod.__esModule) return mod;
+    var result = {};
+    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
+    __setModuleDefault(result, mod);
+    return result;
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.TrezorConnectBridge = void 0;
+const connect_web_1 = __importStar(require("@trezor/connect-web"));
+class TrezorConnectBridge {
+    init(settings) {
+        connect_web_1.default.on(connect_web_1.DEVICE_EVENT, (event) => {
+            var _a;
+            if (event.type !== connect_web_1.DEVICE.CONNECT) {
+                return;
+            }
+            this.model = (_a = event.payload.features) === null || _a === void 0 ? void 0 : _a.model;
+        });
+        return connect_web_1.default.init(settings);
+    }
+    dispose() {
+        // This removes the Trezor Connect iframe from the DOM
+        // This method is not well documented, but the code it calls can be seen
+        // here: https://github.com/trezor/connect/blob/dec4a56af8a65a6059fb5f63fa3c6690d2c37e00/src/js/iframe/builder.js#L181
+        connect_web_1.default.dispose();
+        return Promise.resolve();
+    }
+    getPublicKey(params) {
+        return connect_web_1.default.getPublicKey(params);
+    }
+    ethereumSignTransaction(params) {
+        return connect_web_1.default.ethereumSignTransaction(params);
+    }
+    ethereumSignMessage(params) {
+        return connect_web_1.default.ethereumSignMessage(params);
+    }
+    ethereumSignTypedData(params) {
+        return connect_web_1.default.ethereumSignTypedData(params);
+    }
+}
+exports.TrezorConnectBridge = TrezorConnectBridge;
+//# sourceMappingURL=trezor-connect-bridge.js.map
\ No newline at end of file
diff --git a/dist/trezor-connect-bridge.js.map b/dist/trezor-connect-bridge.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..be3f17a1b2b067e69661fb0f74ceb7b8f38e928d
--- /dev/null
+++ b/dist/trezor-connect-bridge.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"trezor-connect-bridge.js","sourceRoot":"","sources":["../src/trezor-connect-bridge.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,mEAA0E;AAY1E,MAAa,mBAAmB;IAG9B,IAAI,CACF,QAE4B;QAE5B,qBAAa,CAAC,EAAE,CAAC,0BAAY,EAAE,CAAC,KAAK,EAAE,EAAE;;YACvC,IAAI,KAAK,CAAC,IAAI,KAAK,oBAAM,CAAC,OAAO,EAAE;gBACjC,OAAO;aACR;YAED,IAAI,CAAC,KAAK,GAAG,MAAA,KAAK,CAAC,OAAO,CAAC,QAAQ,0CAAE,KAAK,CAAC;QAC7C,CAAC,CAAC,CAAC;QAEH,OAAO,qBAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IACtC,CAAC;IAED,OAAO;QACL,sDAAsD;QACtD,wEAAwE;QACxE,sHAAsH;QACtH,qBAAa,CAAC,OAAO,EAAE,CAAC;QACxB,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;IAC3B,CAAC;IAED,YAAY,CAAC,MAAsC;QACjD,OAAO,qBAAa,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;IAC5C,CAAC;IAED,uBAAuB,CAAC,MAAuC;QAC7D,OAAO,qBAAa,CAAC,uBAAuB,CAAC,MAAM,CAAC,CAAC;IACvD,CAAC;IAED,mBAAmB,CAAC,MAAmC;QACrD,OAAO,qBAAa,CAAC,mBAAmB,CAAC,MAAM,CAAC,CAAC;IACnD,CAAC;IAED,qBAAqB,CACnB,MAAiE;QAEjE,OAAO,qBAAa,CAAC,qBAAqB,CAAC,MAAM,CAAC,CAAC;IACrD,CAAC;CACF;AA5CD,kDA4CC","sourcesContent":["import TrezorConnect, { DEVICE_EVENT, DEVICE } from '@trezor/connect-web';\nimport type {\n  Manifest,\n  ConnectSettings,\n  EthereumSignTransaction,\n  Params,\n  EthereumSignMessage,\n  EthereumSignTypedDataTypes,\n  EthereumSignTypedHash,\n} from '@trezor/connect-web';\nimport type { TrezorBridge } from './trezor-bridge';\n\nexport class TrezorConnectBridge implements TrezorBridge {\n  model?: string;\n\n  init(\n    settings: {\n      manifest: Manifest;\n    } & Partial<ConnectSettings>,\n  ) {\n    TrezorConnect.on(DEVICE_EVENT, (event) => {\n      if (event.type !== DEVICE.CONNECT) {\n        return;\n      }\n\n      this.model = event.payload.features?.model;\n    });\n\n    return TrezorConnect.init(settings);\n  }\n\n  dispose() {\n    // This removes the Trezor Connect iframe from the DOM\n    // This method is not well documented, but the code it calls can be seen\n    // here: https://github.com/trezor/connect/blob/dec4a56af8a65a6059fb5f63fa3c6690d2c37e00/src/js/iframe/builder.js#L181\n    TrezorConnect.dispose();\n    return Promise.resolve();\n  }\n\n  getPublicKey(params: { path: string; coin: string }) {\n    return TrezorConnect.getPublicKey(params);\n  }\n\n  ethereumSignTransaction(params: Params<EthereumSignTransaction>) {\n    return TrezorConnect.ethereumSignTransaction(params);\n  }\n\n  ethereumSignMessage(params: Params<EthereumSignMessage>) {\n    return TrezorConnect.ethereumSignMessage(params);\n  }\n\n  ethereumSignTypedData(\n    params: Params<EthereumSignTypedHash<EthereumSignTypedDataTypes>>,\n  ) {\n    return TrezorConnect.ethereumSignTypedData(params);\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/trezor-keyring.d.ts b/dist/trezor-keyring.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7db3fd07738d459bf5b69dbd55eadb84791e7935
--- /dev/null
+++ b/dist/trezor-keyring.d.ts
@@ -0,0 +1,112 @@
+/// <reference types="node" />
+import { EventEmitter } from 'events';
+import HDKey from 'hdkey';
+import type { EthereumSignTypedDataTypes } from '@trezor/connect-web';
+import type { TypedTransaction } from '@ethereumjs/tx';
+import type OldEthJsTransaction from 'ethereumjs-tx';
+import { TypedMessage, SignTypedDataVersion } from '@metamask/eth-sig-util';
+import { TrezorBridge } from './trezor-bridge';
+declare const ALLOWED_HD_PATHS: {
+    readonly "m/44'/60'/0'/0": true;
+    readonly "m/44'/1'/0'/0": true;
+};
+export declare const TREZOR_CONNECT_METAMASK_MANIFEST: {
+    email: string;
+    appUrl: string;
+};
+export interface TrezorControllerOptions {
+    hdPath?: string;
+    accounts?: string[];
+    page?: number;
+    perPage?: number;
+}
+export interface TrezorControllerState {
+    hdPath: string;
+    accounts: readonly string[];
+    page: number;
+    paths: Record<string, number>;
+    perPage: number;
+    unlockedAccount: number;
+}
+export declare class TrezorKeyring extends EventEmitter {
+    #private;
+    static type: string;
+    readonly type: string;
+    accounts: readonly string[];
+    hdk: HDKey;
+    hdPath: string;
+    page: number;
+    perPage: number;
+    unlockedAccount: number;
+    paths: Record<string, number>;
+    bridge: TrezorBridge;
+    constructor({ bridge }: {
+        bridge: TrezorBridge;
+    });
+    /**
+     * Gets the model, if known.
+     * This may be `undefined` if the model hasn't been loaded yet.
+     *
+     * @returns
+     */
+    getModel(): string | undefined;
+    init(): Promise<void>;
+    dispose(): Promise<void>;
+    serialize(): Promise<TrezorControllerState>;
+    deserialize(opts?: TrezorControllerOptions): Promise<void>;
+    isUnlocked(): boolean;
+    unlock(): Promise<unknown>;
+    setAccountToUnlock(index: number | string): void;
+    addAccounts(n?: number): Promise<readonly string[]>;
+    getFirstPage(): Promise<{
+        address: string;
+        balance: number | null;
+        index: number;
+    }[]>;
+    getNextPage(): Promise<{
+        address: string;
+        balance: number | null;
+        index: number;
+    }[]>;
+    getPreviousPage(): Promise<{
+        address: string;
+        balance: number | null;
+        index: number;
+    }[]>;
+    getAccounts(): Promise<string[]>;
+    removeAccount(address: string): void;
+    /**
+     * Signs a transaction using Trezor.
+     *
+     * Accepts either an ethereumjs-tx or @ethereumjs/tx transaction, and returns
+     * the same type.
+     *
+     * @param address - Hex string address.
+     * @param tx - Instance of either new-style or old-style ethereumjs transaction.
+     * @returns The signed transaction, an instance of either new-style or old-style
+     * ethereumjs transaction.
+     */
+    signTransaction(address: string, tx: TypedTransaction | OldEthJsTransaction): Promise<TypedTransaction | OldEthJsTransaction>;
+    signMessage(withAccount: string, data: string): Promise<unknown>;
+    signPersonalMessage(withAccount: string, message: string): Promise<unknown>;
+    /**
+     * EIP-712 Sign Typed Data
+     */
+    signTypedData(address: string, data: TypedMessage<EthereumSignTypedDataTypes>, { version }: {
+        version: SignTypedDataVersion;
+    }): Promise<string>;
+    exportAccount(): Promise<never>;
+    forgetDevice(): void;
+    /**
+     * Set the HD path to be used by the keyring. Only known supported HD paths are allowed.
+     *
+     * If the given HD path is already the current HD path, nothing happens. Otherwise the new HD
+     * path is set, and the wallet state is completely reset.
+     *
+     * @throws {Error] Throws if the HD path is not supported.
+     *
+     * @param hdPath - The HD path to set.
+     */
+    setHdPath(hdPath: keyof typeof ALLOWED_HD_PATHS): void;
+}
+export {};
diff --git a/dist/trezor-keyring.js b/dist/trezor-keyring.js
new file mode 100644
index 0000000000000000000000000000000000000000..3341179d8a5b904c6e628acd64c9d21469e0f481
--- /dev/null
+++ b/dist/trezor-keyring.js
@@ -0,0 +1,468 @@
+"use strict";
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
+    Object.defineProperty(o, "default", { enumerable: true, value: v });
+}) : function(o, v) {
+    o["default"] = v;
+});
+var __importStar = (this && this.__importStar) || function (mod) {
+    if (mod && mod.__esModule) return mod;
+    var result = {};
+    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
+    __setModuleDefault(result, mod);
+    return result;
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+var _TrezorKeyring_instances, _TrezorKeyring_getPage, _TrezorKeyring_signTransaction, _TrezorKeyring_normalize, _TrezorKeyring_addressFromIndex, _TrezorKeyring_pathFromAddress;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.TrezorKeyring = exports.TREZOR_CONNECT_METAMASK_MANIFEST = void 0;
+const events_1 = require("events");
+const ethUtil = __importStar(require("@ethereumjs/util"));
+const hdkey_1 = __importDefault(require("hdkey"));
+const tx_1 = require("@ethereumjs/tx");
+const connect_plugin_ethereum_1 = require("@trezor/connect-plugin-ethereum");
+const hdPathString = `m/44'/60'/0'/0`;
+const SLIP0044TestnetPath = `m/44'/1'/0'/0`;
+const ALLOWED_HD_PATHS = {
+    [hdPathString]: true,
+    [SLIP0044TestnetPath]: true,
+};
+const keyringType = 'Trezor Hardware';
+const pathBase = 'm';
+const MAX_INDEX = 1000;
+const DELAY_BETWEEN_POPUPS = 1000;
+exports.TREZOR_CONNECT_METAMASK_MANIFEST = {
+    email: 'support@metamask.io',
+    appUrl: 'https://metamask.io',
+};
+async function wait(ms) {
+    return new Promise((resolve) => setTimeout(resolve, ms));
+}
+/**
+ * Check if the given transaction is made with ethereumjs-tx or @ethereumjs/tx
+ *
+ * Transactions built with older versions of ethereumjs-tx have a
+ * getChainId method that newer versions do not.
+ * Older versions are mutable
+ * while newer versions default to being immutable.
+ * Expected shape and type
+ * of data for v, r and s differ (Buffer (old) vs BN (new)).
+ *
+ * @param tx
+ * @returns Returns `true` if tx is an old-style ethereumjs-tx transaction.
+ */
+function isOldStyleEthereumjsTx(tx) {
+    return typeof tx.getChainId === 'function';
+}
+class TrezorKeyring extends events_1.EventEmitter {
+    constructor({ bridge }) {
+        super();
+        _TrezorKeyring_instances.add(this);
+        this.type = keyringType;
+        this.accounts = [];
+        this.hdk = new hdkey_1.default();
+        this.hdPath = hdPathString;
+        this.page = 0;
+        this.perPage = 5;
+        this.unlockedAccount = 0;
+        this.paths = {};
+        if (!bridge) {
+            throw new Error('Bridge is a required dependency for the keyring');
+        }
+        this.bridge = bridge;
+    }
+    /**
+     * Gets the model, if known.
+     * This may be `undefined` if the model hasn't been loaded yet.
+     *
+     * @returns
+     */
+    getModel() {
+        return this.bridge.model;
+    }
+    init() {
+        return this.bridge.init({
+            manifest: exports.TREZOR_CONNECT_METAMASK_MANIFEST,
+            lazyLoad: true,
+        });
+    }
+    dispose() {
+        return this.bridge.dispose();
+    }
+    async serialize() {
+        return Promise.resolve({
+            hdPath: this.hdPath,
+            accounts: this.accounts,
+            page: this.page,
+            paths: this.paths,
+            perPage: this.perPage,
+            unlockedAccount: this.unlockedAccount,
+        });
+    }
+    async deserialize(opts = {}) {
+        var _a, _b, _c, _d;
+        this.hdPath = (_a = opts.hdPath) !== null && _a !== void 0 ? _a : hdPathString;
+        this.accounts = (_b = opts.accounts) !== null && _b !== void 0 ? _b : [];
+        this.page = (_c = opts.page) !== null && _c !== void 0 ? _c : 0;
+        this.perPage = (_d = opts.perPage) !== null && _d !== void 0 ? _d : 5;
+        return Promise.resolve();
+    }
+    isUnlocked() {
+        var _a;
+        return Boolean((_a = this.hdk) === null || _a === void 0 ? void 0 : _a.publicKey);
+    }
+    async unlock() {
+        if (this.isUnlocked()) {
+            return Promise.resolve('already unlocked');
+        }
+        return new Promise((resolve, reject) => {
+            this.bridge
+                .getPublicKey({
+                path: this.hdPath,
+                coin: 'ETH',
+            })
+                .then((response) => {
+                var _a;
+                if (response.success) {
+                    this.hdk.publicKey = Buffer.from(response.payload.publicKey, 'hex');
+                    this.hdk.chainCode = Buffer.from(response.payload.chainCode, 'hex');
+                    resolve('just unlocked');
+                }
+                else {
+                    reject(new Error(((_a = response.payload) === null || _a === void 0 ? void 0 : _a.error) || 'Unknown error'));
+                }
+            })
+                .catch((e) => {
+                reject(new Error((e === null || e === void 0 ? void 0 : e.toString()) || 'Unknown error'));
+            });
+        });
+    }
+    setAccountToUnlock(index) {
+        this.unlockedAccount = parseInt(String(index), 10);
+    }
+    async addAccounts(n = 1) {
+        return new Promise((resolve, reject) => {
+            this.unlock()
+                .then((_) => {
+                const from = this.unlockedAccount;
+                const to = from + n;
+                for (let i = from; i < to; i++) {
+                    const address = __classPrivateFieldGet(this, _TrezorKeyring_instances, "m", _TrezorKeyring_addressFromIndex).call(this, pathBase, i);
+                    if (!this.accounts.includes(address)) {
+                        this.accounts = [...this.accounts, address];
+                    }
+                    this.page = 0;
+                }
+                resolve(this.accounts);
+            })
+                .catch((e) => {
+                reject(e);
+            });
+        });
+    }
+    async getFirstPage() {
+        this.page = 0;
+        return __classPrivateFieldGet(this, _TrezorKeyring_instances, "m", _TrezorKeyring_getPage).call(this, 1);
+    }
+    async getNextPage() {
+        return __classPrivateFieldGet(this, _TrezorKeyring_instances, "m", _TrezorKeyring_getPage).call(this, 1);
+    }
+    async getPreviousPage() {
+        return __classPrivateFieldGet(this, _TrezorKeyring_instances, "m", _TrezorKeyring_getPage).call(this, -1);
+    }
+    async getAccounts() {
+        return Promise.resolve(this.accounts.slice());
+    }
+    removeAccount(address) {
+        if (!this.accounts.map((a) => a.toLowerCase()).includes(address.toLowerCase())) {
+            throw new Error(`Address ${address} not found in this keyring`);
+        }
+        this.accounts = this.accounts.filter((a) => a.toLowerCase() !== address.toLowerCase());
+    }
+    /**
+     * Signs a transaction using Trezor.
+     *
+     * Accepts either an ethereumjs-tx or @ethereumjs/tx transaction, and returns
+     * the same type.
+     *
+     * @param address - Hex string address.
+     * @param tx - Instance of either new-style or old-style ethereumjs transaction.
+     * @returns The signed transaction, an instance of either new-style or old-style
+     * ethereumjs transaction.
+     */
+    async signTransaction(address, tx) {
+        if (isOldStyleEthereumjsTx(tx)) {
+            // In this version of ethereumjs-tx we must add the chainId in hex format
+            // to the initial v value. The chainId must be included in the serialized
+            // transaction which is only communicated to ethereumjs-tx in this
+            // value. In newer versions the chainId is communicated via the 'Common'
+            // object.
+            return __classPrivateFieldGet(this, _TrezorKeyring_instances, "m", _TrezorKeyring_signTransaction).call(this, address, 
+            // @types/ethereumjs-tx and old ethereumjs-tx versions document
+            // this function return value as Buffer, but the actual
+            // Transaction._chainId will always be a number.
+            // See https://github.com/ethereumjs/ethereumjs-tx/blob/v1.3.7/index.js#L126
+            tx.getChainId(), tx, (payload) => {
+                tx.v = Buffer.from(payload.v, 'hex');
+                tx.r = Buffer.from(payload.r, 'hex');
+                tx.s = Buffer.from(payload.s, 'hex');
+                return tx;
+            });
+        }
+        return __classPrivateFieldGet(this, _TrezorKeyring_instances, "m", _TrezorKeyring_signTransaction).call(this, address, Number(tx.common.chainId()), tx, (payload) => {
+            // Because tx will be immutable, first get a plain javascript object that
+            // represents the transaction. Using txData here as it aligns with the
+            // nomenclature of ethereumjs/tx.
+            const txData = tx.toJSON();
+            // The fromTxData utility expects a type to support transactions with a type other than 0
+            txData.type = tx.type;
+            // The fromTxData utility expects v,r and s to be hex prefixed
+            txData.v = ethUtil.addHexPrefix(payload.v);
+            txData.r = ethUtil.addHexPrefix(payload.r);
+            txData.s = ethUtil.addHexPrefix(payload.s);
+            // Adopt the 'common' option from the original transaction and set the
+            // returned object to be frozen if the original is frozen.
+            return tx_1.TransactionFactory.fromTxData(txData, {
+                common: tx.common,
+                freeze: Object.isFrozen(tx),
+            });
+        });
+    }
+    async signMessage(withAccount, data) {
+        return this.signPersonalMessage(withAccount, data);
+    }
+    // For personal_sign, we need to prefix the message:
+    async signPersonalMessage(withAccount, message) {
+        return new Promise((resolve, reject) => {
+            this.unlock()
+                .then((status) => {
+                setTimeout(() => {
+                    this.bridge
+                        .ethereumSignMessage({
+                        path: __classPrivateFieldGet(this, _TrezorKeyring_instances, "m", _TrezorKeyring_pathFromAddress).call(this, withAccount),
+                        message: ethUtil.stripHexPrefix(message),
+                        hex: true,
+                    })
+                        .then((response) => {
+                        var _a;
+                        if (response.success) {
+                            if (response.payload.address !==
+                                ethUtil.toChecksumAddress(withAccount)) {
+                                reject(new Error('signature doesnt match the right address'));
+                            }
+                            const signature = `0x${response.payload.signature}`;
+                            resolve(signature);
+                        }
+                        else {
+                            reject(new Error(((_a = response.payload) === null || _a === void 0 ? void 0 : _a.error) || 'Unknown error'));
+                        }
+                    })
+                        .catch((e) => {
+                        reject(new Error((e === null || e === void 0 ? void 0 : e.toString()) || 'Unknown error'));
+                    });
+                    // This is necessary to avoid popup collision
+                    // between the unlock & sign trezor popups
+                }, status === 'just unlocked' ? DELAY_BETWEEN_POPUPS : 0);
+            })
+                .catch((e) => {
+                reject(new Error((e === null || e === void 0 ? void 0 : e.toString()) || 'Unknown error'));
+            });
+        });
+    }
+    /**
+     * EIP-712 Sign Typed Data
+     */
+    async signTypedData(address, data, { version }) {
+        var _a, _b;
+        const dataWithHashes = (0, connect_plugin_ethereum_1.transformTypedData)(data, version === 'V4');
+        // set default values for signTypedData
+        // Trezor is stricter than @metamask/eth-sig-util in what it accepts
+        const { types, message = {}, domain = {}, primaryType, 
+        // snake_case since Trezor uses Protobuf naming conventions here
+        domain_separator_hash, // eslint-disable-line camelcase
+        message_hash, // eslint-disable-line camelcase
+         } = dataWithHashes;
+        // This is necessary to avoid popup collision
+        // between the unlock & sign trezor popups
+        const status = await this.unlock();
+        await wait(status === 'just unlocked' ? DELAY_BETWEEN_POPUPS : 0);
+        const response = await this.bridge.ethereumSignTypedData({
+            path: __classPrivateFieldGet(this, _TrezorKeyring_instances, "m", _TrezorKeyring_pathFromAddress).call(this, address),
+            data: {
+                types: Object.assign(Object.assign({}, types), { EIP712Domain: (_a = types.EIP712Domain) !== null && _a !== void 0 ? _a : [] }),
+                message,
+                domain,
+                primaryType,
+            },
+            metamask_v4_compat: true,
+            // Trezor 1 only supports blindly signing hashes
+            domain_separator_hash,
+            message_hash: message_hash !== null && message_hash !== void 0 ? message_hash : '', // eslint-disable-line camelcase
+        });
+        if (response.success) {
+            if (ethUtil.toChecksumAddress(address) !== response.payload.address) {
+                throw new Error('signature doesnt match the right address');
+            }
+            return response.payload.signature;
+        }
+        throw new Error(((_b = response.payload) === null || _b === void 0 ? void 0 : _b.error) || 'Unknown error');
+    }
+    async exportAccount() {
+        return Promise.reject(new Error('Not supported on this device'));
+    }
+    forgetDevice() {
+        this.accounts = [];
+        this.hdk = new hdkey_1.default();
+        this.page = 0;
+        this.unlockedAccount = 0;
+        this.paths = {};
+    }
+    /**
+     * Set the HD path to be used by the keyring. Only known supported HD paths are allowed.
+     *
+     * If the given HD path is already the current HD path, nothing happens. Otherwise the new HD
+     * path is set, and the wallet state is completely reset.
+     *
+     * @throws {Error] Throws if the HD path is not supported.
+     *
+     * @param hdPath - The HD path to set.
+     */
+    setHdPath(hdPath) {
+        if (!ALLOWED_HD_PATHS[hdPath]) {
+            throw new Error(`The setHdPath method does not support setting HD Path to ${hdPath}`);
+        }
+        // Reset HDKey if the path changes
+        if (this.hdPath !== hdPath) {
+            this.hdk = new hdkey_1.default();
+            this.accounts = [];
+            this.page = 0;
+            this.perPage = 5;
+            this.unlockedAccount = 0;
+            this.paths = {};
+        }
+        this.hdPath = hdPath;
+    }
+}
+exports.TrezorKeyring = TrezorKeyring;
+_TrezorKeyring_instances = new WeakSet(), _TrezorKeyring_getPage = async function _TrezorKeyring_getPage(increment) {
+    this.page += increment;
+    if (this.page <= 0) {
+        this.page = 1;
+    }
+    return new Promise((resolve, reject) => {
+        this.unlock()
+            .then((_) => {
+            const from = (this.page - 1) * this.perPage;
+            const to = from + this.perPage;
+            const accounts = [];
+            for (let i = from; i < to; i++) {
+                const address = __classPrivateFieldGet(this, _TrezorKeyring_instances, "m", _TrezorKeyring_addressFromIndex).call(this, pathBase, i);
+                accounts.push({
+                    address,
+                    balance: null,
+                    index: i,
+                });
+                this.paths[ethUtil.toChecksumAddress(address)] = i;
+            }
+            resolve(accounts);
+        })
+            .catch((e) => {
+            reject(e);
+        });
+    });
+}, _TrezorKeyring_signTransaction = 
+/**
+ *
+ * @param address - Hex string address.
+ * @param chainId - Chain ID
+ * @param tx - Instance of either new-style or old-style ethereumjs transaction.
+ * @param handleSigning - Converts signed transaction
+ * to the same new-style or old-style ethereumjs-tx.
+ * @returns The signed transaction, an instance of either new-style or old-style
+ * ethereumjs transaction.
+ */
+async function _TrezorKeyring_signTransaction(address, chainId, tx, handleSigning) {
+    var _a, _b;
+    let transaction;
+    if (isOldStyleEthereumjsTx(tx)) {
+        // legacy transaction from ethereumjs-tx package has no .toJSON() function,
+        // so we need to convert to hex-strings manually manually
+        transaction = {
+            to: __classPrivateFieldGet(this, _TrezorKeyring_instances, "m", _TrezorKeyring_normalize).call(this, tx.to),
+            value: __classPrivateFieldGet(this, _TrezorKeyring_instances, "m", _TrezorKeyring_normalize).call(this, tx.value),
+            data: __classPrivateFieldGet(this, _TrezorKeyring_instances, "m", _TrezorKeyring_normalize).call(this, tx.data),
+            chainId,
+            nonce: __classPrivateFieldGet(this, _TrezorKeyring_instances, "m", _TrezorKeyring_normalize).call(this, tx.nonce),
+            gasLimit: __classPrivateFieldGet(this, _TrezorKeyring_instances, "m", _TrezorKeyring_normalize).call(this, tx.gasLimit),
+            gasPrice: __classPrivateFieldGet(this, _TrezorKeyring_instances, "m", _TrezorKeyring_normalize).call(this, tx.gasPrice),
+        };
+    }
+    else {
+        // new-style transaction from @ethereumjs/tx package
+        // we can just copy tx.toJSON() for everything except chainId, which must be a number
+        transaction = Object.assign(Object.assign({}, tx.toJSON()), { chainId, to: __classPrivateFieldGet(this, _TrezorKeyring_instances, "m", _TrezorKeyring_normalize).call(this, ethUtil.toBuffer(tx.to)) });
+    }
+    try {
+        const status = await this.unlock();
+        await wait(status === 'just unlocked' ? DELAY_BETWEEN_POPUPS : 0);
+        const response = await this.bridge.ethereumSignTransaction({
+            path: __classPrivateFieldGet(this, _TrezorKeyring_instances, "m", _TrezorKeyring_pathFromAddress).call(this, address),
+            transaction,
+        });
+        if (response.success) {
+            const newOrMutatedTx = handleSigning(response.payload);
+            const addressSignedWith = ethUtil.toChecksumAddress(ethUtil.addHexPrefix(newOrMutatedTx.getSenderAddress().toString('hex')));
+            const correctAddress = ethUtil.toChecksumAddress(address);
+            if (addressSignedWith !== correctAddress) {
+                throw new Error("signature doesn't match the right address");
+            }
+            return newOrMutatedTx;
+        }
+        throw new Error(((_a = response.payload) === null || _a === void 0 ? void 0 : _a.error) || 'Unknown error');
+    }
+    catch (e) {
+        throw new Error((_b = e === null || e === void 0 ? void 0 : e.toString()) !== null && _b !== void 0 ? _b : 'Unknown error');
+    }
+}, _TrezorKeyring_normalize = function _TrezorKeyring_normalize(buf) {
+    return ethUtil.bufferToHex(buf).toString();
+}, _TrezorKeyring_addressFromIndex = function _TrezorKeyring_addressFromIndex(basePath, i) {
+    const dkey = this.hdk.derive(`${basePath}/${i}`);
+    const address = ethUtil
+        .publicToAddress(dkey.publicKey, true)
+        .toString('hex');
+    return ethUtil.toChecksumAddress(`0x${address}`);
+}, _TrezorKeyring_pathFromAddress = function _TrezorKeyring_pathFromAddress(address) {
+    const checksummedAddress = ethUtil.toChecksumAddress(address);
+    let index = this.paths[checksummedAddress];
+    if (typeof index === 'undefined') {
+        for (let i = 0; i < MAX_INDEX; i++) {
+            if (checksummedAddress === __classPrivateFieldGet(this, _TrezorKeyring_instances, "m", _TrezorKeyring_addressFromIndex).call(this, pathBase, i)) {
+                index = i;
+                break;
+            }
+        }
+    }
+    if (typeof index === 'undefined') {
+        throw new Error('Unknown address');
+    }
+    return `${this.hdPath}/${index}`;
+};
+TrezorKeyring.type = keyringType;
+//# sourceMappingURL=trezor-keyring.js.map
\ No newline at end of file
diff --git a/dist/trezor-keyring.js.map b/dist/trezor-keyring.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..d8af1c17231e1a776d3a11a55d5f332c40d9704d
--- /dev/null
+++ b/dist/trezor-keyring.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"trezor-keyring.js","sourceRoot":"","sources":["../src/trezor-keyring.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport * as ethUtil from '@ethereumjs/util';\nimport HDKey from 'hdkey';\nimport type {\n  EthereumTransactionEIP1559,\n  EthereumSignedTx,\n  EthereumTransaction,\n  EthereumSignTypedDataTypes,\n} from '@trezor/connect-web';\nimport { TransactionFactory } from '@ethereumjs/tx';\nimport type { TypedTransaction, TxData } from '@ethereumjs/tx';\nimport type OldEthJsTransaction from 'ethereumjs-tx';\nimport { transformTypedData } from '@trezor/connect-plugin-ethereum';\nimport { TypedMessage, SignTypedDataVersion } from '@metamask/eth-sig-util';\nimport { TrezorBridge } from './trezor-bridge';\n\nconst hdPathString = `m/44'/60'/0'/0`;\nconst SLIP0044TestnetPath = `m/44'/1'/0'/0`;\n\nconst ALLOWED_HD_PATHS = {\n  [hdPathString]: true,\n  [SLIP0044TestnetPath]: true,\n} as const;\n\nconst keyringType = 'Trezor Hardware';\nconst pathBase = 'm';\nconst MAX_INDEX = 1000;\nconst DELAY_BETWEEN_POPUPS = 1000;\nexport const TREZOR_CONNECT_METAMASK_MANIFEST = {\n  email: 'support@metamask.io',\n  appUrl: 'https://metamask.io',\n};\n\nexport interface TrezorControllerOptions {\n  hdPath?: string;\n  accounts?: string[];\n  page?: number;\n  perPage?: number;\n}\n\nexport interface TrezorControllerState {\n  hdPath: string;\n  accounts: readonly string[];\n  page: number;\n  paths: Record<string, number>;\n  perPage: number;\n  unlockedAccount: number;\n}\n\nasync function wait(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n/**\n * Check if the given transaction is made with ethereumjs-tx or @ethereumjs/tx\n *\n * Transactions built with older versions of ethereumjs-tx have a\n * getChainId method that newer versions do not.\n * Older versions are mutable\n * while newer versions default to being immutable.\n * Expected shape and type\n * of data for v, r and s differ (Buffer (old) vs BN (new)).\n *\n * @param tx\n * @returns Returns `true` if tx is an old-style ethereumjs-tx transaction.\n */\nfunction isOldStyleEthereumjsTx(\n  tx: TypedTransaction | OldEthJsTransaction,\n): tx is OldEthJsTransaction {\n  return typeof (tx as OldEthJsTransaction).getChainId === 'function';\n}\n\nexport class TrezorKeyring extends EventEmitter {\n  static type: string = keyringType;\n\n  readonly type: string = keyringType;\n\n  accounts: readonly string[] = [];\n\n  hdk: HDKey = new HDKey();\n\n  hdPath: string = hdPathString;\n\n  page = 0;\n\n  perPage = 5;\n\n  unlockedAccount = 0;\n\n  paths: Record<string, number> = {};\n\n  bridge: TrezorBridge;\n\n  constructor({ bridge }: { bridge: TrezorBridge }) {\n    super();\n\n    if (!bridge) {\n      throw new Error('Bridge is a required dependency for the keyring');\n    }\n\n    this.bridge = bridge;\n  }\n\n  /**\n   * Gets the model, if known.\n   * This may be `undefined` if the model hasn't been loaded yet.\n   *\n   * @returns\n   */\n  getModel(): string | undefined {\n    return this.bridge.model;\n  }\n\n  init() {\n    return this.bridge.init({\n      manifest: TREZOR_CONNECT_METAMASK_MANIFEST,\n      lazyLoad: true,\n    });\n  }\n\n  dispose() {\n    return this.bridge.dispose();\n  }\n\n  async serialize(): Promise<TrezorControllerState> {\n    return Promise.resolve({\n      hdPath: this.hdPath,\n      accounts: this.accounts,\n      page: this.page,\n      paths: this.paths,\n      perPage: this.perPage,\n      unlockedAccount: this.unlockedAccount,\n    });\n  }\n\n  async deserialize(opts: TrezorControllerOptions = {}) {\n    this.hdPath = opts.hdPath ?? hdPathString;\n    this.accounts = opts.accounts ?? [];\n    this.page = opts.page ?? 0;\n    this.perPage = opts.perPage ?? 5;\n    return Promise.resolve();\n  }\n\n  isUnlocked() {\n    return Boolean(this.hdk?.publicKey);\n  }\n\n  async unlock() {\n    if (this.isUnlocked()) {\n      return Promise.resolve('already unlocked');\n    }\n    return new Promise((resolve, reject) => {\n      this.bridge\n        .getPublicKey({\n          path: this.hdPath,\n          coin: 'ETH',\n        })\n        .then((response) => {\n          if (response.success) {\n            this.hdk.publicKey = Buffer.from(response.payload.publicKey, 'hex');\n            this.hdk.chainCode = Buffer.from(response.payload.chainCode, 'hex');\n            resolve('just unlocked');\n          } else {\n            reject(new Error(response.payload?.error || 'Unknown error'));\n          }\n        })\n        .catch((e) => {\n          reject(new Error(e?.toString() || 'Unknown error'));\n        });\n    });\n  }\n\n  setAccountToUnlock(index: number | string) {\n    this.unlockedAccount = parseInt(String(index), 10);\n  }\n\n  async addAccounts(n = 1): Promise<readonly string[]> {\n    return new Promise((resolve, reject) => {\n      this.unlock()\n        .then((_) => {\n          const from = this.unlockedAccount;\n          const to = from + n;\n\n          for (let i = from; i < to; i++) {\n            const address = this.#addressFromIndex(pathBase, i);\n            if (!this.accounts.includes(address)) {\n              this.accounts = [...this.accounts, address];\n            }\n            this.page = 0;\n          }\n          resolve(this.accounts);\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n  }\n\n  async getFirstPage() {\n    this.page = 0;\n    return this.#getPage(1);\n  }\n\n  async getNextPage() {\n    return this.#getPage(1);\n  }\n\n  async getPreviousPage() {\n    return this.#getPage(-1);\n  }\n\n  async #getPage(\n    increment: number,\n  ): Promise<{ address: string; balance: number | null; index: number }[]> {\n    this.page += increment;\n\n    if (this.page <= 0) {\n      this.page = 1;\n    }\n\n    return new Promise((resolve, reject) => {\n      this.unlock()\n        .then((_) => {\n          const from = (this.page - 1) * this.perPage;\n          const to = from + this.perPage;\n\n          const accounts = [];\n\n          for (let i = from; i < to; i++) {\n            const address = this.#addressFromIndex(pathBase, i);\n            accounts.push({\n              address,\n              balance: null,\n              index: i,\n            });\n            this.paths[ethUtil.toChecksumAddress(address)] = i;\n          }\n          resolve(accounts);\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n  }\n\n  async getAccounts() {\n    return Promise.resolve(this.accounts.slice());\n  }\n\n  removeAccount(address: string) {\n    if (\n      !this.accounts.map((a) => a.toLowerCase()).includes(address.toLowerCase())\n    ) {\n      throw new Error(`Address ${address} not found in this keyring`);\n    }\n\n    this.accounts = this.accounts.filter(\n      (a) => a.toLowerCase() !== address.toLowerCase(),\n    );\n  }\n\n  /**\n   * Signs a transaction using Trezor.\n   *\n   * Accepts either an ethereumjs-tx or @ethereumjs/tx transaction, and returns\n   * the same type.\n   *\n   * @param address - Hex string address.\n   * @param tx - Instance of either new-style or old-style ethereumjs transaction.\n   * @returns The signed transaction, an instance of either new-style or old-style\n   * ethereumjs transaction.\n   */\n  async signTransaction(\n    address: string,\n    tx: TypedTransaction | OldEthJsTransaction,\n  ) {\n    if (isOldStyleEthereumjsTx(tx)) {\n      // In this version of ethereumjs-tx we must add the chainId in hex format\n      // to the initial v value. The chainId must be included in the serialized\n      // transaction which is only communicated to ethereumjs-tx in this\n      // value. In newer versions the chainId is communicated via the 'Common'\n      // object.\n      return this.#signTransaction(\n        address,\n        // @types/ethereumjs-tx and old ethereumjs-tx versions document\n        // this function return value as Buffer, but the actual\n        // Transaction._chainId will always be a number.\n        // See https://github.com/ethereumjs/ethereumjs-tx/blob/v1.3.7/index.js#L126\n        tx.getChainId() as unknown as number,\n        tx,\n        (payload) => {\n          tx.v = Buffer.from(payload.v, 'hex');\n          tx.r = Buffer.from(payload.r, 'hex');\n          tx.s = Buffer.from(payload.s, 'hex');\n          return tx;\n        },\n      );\n    }\n    return this.#signTransaction(\n      address,\n      Number(tx.common.chainId()),\n      tx,\n      (payload) => {\n        // Because tx will be immutable, first get a plain javascript object that\n        // represents the transaction. Using txData here as it aligns with the\n        // nomenclature of ethereumjs/tx.\n        const txData: TxData = tx.toJSON();\n        // The fromTxData utility expects a type to support transactions with a type other than 0\n        txData.type = tx.type;\n        // The fromTxData utility expects v,r and s to be hex prefixed\n        txData.v = ethUtil.addHexPrefix(payload.v);\n        txData.r = ethUtil.addHexPrefix(payload.r);\n        txData.s = ethUtil.addHexPrefix(payload.s);\n        // Adopt the 'common' option from the original transaction and set the\n        // returned object to be frozen if the original is frozen.\n        return TransactionFactory.fromTxData(txData, {\n          common: tx.common,\n          freeze: Object.isFrozen(tx),\n        });\n      },\n    );\n  }\n\n  /**\n   *\n   * @param address - Hex string address.\n   * @param chainId - Chain ID\n   * @param tx - Instance of either new-style or old-style ethereumjs transaction.\n   * @param handleSigning - Converts signed transaction\n   * to the same new-style or old-style ethereumjs-tx.\n   * @returns The signed transaction, an instance of either new-style or old-style\n   * ethereumjs transaction.\n   */\n  async #signTransaction<T extends TypedTransaction | OldEthJsTransaction>(\n    address: string,\n    chainId: number,\n    tx: T,\n    handleSigning: (tx: EthereumSignedTx) => T,\n  ): Promise<T> {\n    let transaction: EthereumTransaction | EthereumTransactionEIP1559;\n    if (isOldStyleEthereumjsTx(tx)) {\n      // legacy transaction from ethereumjs-tx package has no .toJSON() function,\n      // so we need to convert to hex-strings manually manually\n      transaction = {\n        to: this.#normalize(tx.to),\n        value: this.#normalize(tx.value),\n        data: this.#normalize(tx.data),\n        chainId,\n        nonce: this.#normalize(tx.nonce),\n        gasLimit: this.#normalize(tx.gasLimit),\n        gasPrice: this.#normalize(tx.gasPrice),\n      };\n    } else {\n      // new-style transaction from @ethereumjs/tx package\n      // we can just copy tx.toJSON() for everything except chainId, which must be a number\n      transaction = {\n        ...tx.toJSON(),\n        chainId,\n        to: this.#normalize(ethUtil.toBuffer(tx.to)),\n      } as EthereumTransaction | EthereumTransactionEIP1559;\n    }\n\n    try {\n      const status = await this.unlock();\n      await wait(status === 'just unlocked' ? DELAY_BETWEEN_POPUPS : 0);\n      const response = await this.bridge.ethereumSignTransaction({\n        path: this.#pathFromAddress(address),\n        transaction,\n      });\n      if (response.success) {\n        const newOrMutatedTx = handleSigning(response.payload);\n\n        const addressSignedWith = ethUtil.toChecksumAddress(\n          ethUtil.addHexPrefix(\n            newOrMutatedTx.getSenderAddress().toString('hex'),\n          ),\n        );\n        const correctAddress = ethUtil.toChecksumAddress(address);\n        if (addressSignedWith !== correctAddress) {\n          throw new Error(\"signature doesn't match the right address\");\n        }\n\n        return newOrMutatedTx;\n      }\n      throw new Error(response.payload?.error || 'Unknown error');\n    } catch (e) {\n      throw new Error(e?.toString() ?? 'Unknown error');\n    }\n  }\n\n  async signMessage(withAccount: string, data: string) {\n    return this.signPersonalMessage(withAccount, data);\n  }\n\n  // For personal_sign, we need to prefix the message:\n  async signPersonalMessage(withAccount: string, message: string) {\n    return new Promise((resolve, reject) => {\n      this.unlock()\n        .then((status) => {\n          setTimeout(\n            () => {\n              this.bridge\n                .ethereumSignMessage({\n                  path: this.#pathFromAddress(withAccount),\n                  message: ethUtil.stripHexPrefix(message),\n                  hex: true,\n                })\n                .then((response) => {\n                  if (response.success) {\n                    if (\n                      response.payload.address !==\n                      ethUtil.toChecksumAddress(withAccount)\n                    ) {\n                      reject(\n                        new Error('signature doesnt match the right address'),\n                      );\n                    }\n                    const signature = `0x${response.payload.signature}`;\n                    resolve(signature);\n                  } else {\n                    reject(\n                      new Error(response.payload?.error || 'Unknown error'),\n                    );\n                  }\n                })\n                .catch((e) => {\n                  reject(new Error(e?.toString() || 'Unknown error'));\n                });\n              // This is necessary to avoid popup collision\n              // between the unlock & sign trezor popups\n            },\n            status === 'just unlocked' ? DELAY_BETWEEN_POPUPS : 0,\n          );\n        })\n        .catch((e) => {\n          reject(new Error(e?.toString() || 'Unknown error'));\n        });\n    });\n  }\n\n  /**\n   * EIP-712 Sign Typed Data\n   */\n  async signTypedData(\n    address: string,\n    data: TypedMessage<EthereumSignTypedDataTypes>,\n    { version }: { version: SignTypedDataVersion },\n  ) {\n    const dataWithHashes = transformTypedData(data, version === 'V4');\n\n    // set default values for signTypedData\n    // Trezor is stricter than @metamask/eth-sig-util in what it accepts\n    const {\n      types,\n      message = {},\n      domain = {},\n      primaryType,\n      // snake_case since Trezor uses Protobuf naming conventions here\n      domain_separator_hash, // eslint-disable-line camelcase\n      message_hash, // eslint-disable-line camelcase\n    } = dataWithHashes;\n\n    // This is necessary to avoid popup collision\n    // between the unlock & sign trezor popups\n    const status = await this.unlock();\n    await wait(status === 'just unlocked' ? DELAY_BETWEEN_POPUPS : 0);\n\n    const response = await this.bridge.ethereumSignTypedData({\n      path: this.#pathFromAddress(address),\n      data: {\n        types: { ...types, EIP712Domain: types.EIP712Domain ?? [] },\n        message,\n        domain,\n        primaryType,\n      },\n      metamask_v4_compat: true, // eslint-disable-line camelcase\n      // Trezor 1 only supports blindly signing hashes\n      domain_separator_hash, // eslint-disable-line camelcase\n      message_hash: message_hash ?? '', // eslint-disable-line camelcase\n    });\n\n    if (response.success) {\n      if (ethUtil.toChecksumAddress(address) !== response.payload.address) {\n        throw new Error('signature doesnt match the right address');\n      }\n      return response.payload.signature;\n    }\n\n    throw new Error(response.payload?.error || 'Unknown error');\n  }\n\n  async exportAccount() {\n    return Promise.reject(new Error('Not supported on this device'));\n  }\n\n  forgetDevice() {\n    this.accounts = [];\n    this.hdk = new HDKey();\n    this.page = 0;\n    this.unlockedAccount = 0;\n    this.paths = {};\n  }\n\n  /**\n   * Set the HD path to be used by the keyring. Only known supported HD paths are allowed.\n   *\n   * If the given HD path is already the current HD path, nothing happens. Otherwise the new HD\n   * path is set, and the wallet state is completely reset.\n   *\n   * @throws {Error] Throws if the HD path is not supported.\n   *\n   * @param hdPath - The HD path to set.\n   */\n  setHdPath(hdPath: keyof typeof ALLOWED_HD_PATHS) {\n    if (!ALLOWED_HD_PATHS[hdPath]) {\n      throw new Error(\n        `The setHdPath method does not support setting HD Path to ${hdPath}`,\n      );\n    }\n\n    // Reset HDKey if the path changes\n    if (this.hdPath !== hdPath) {\n      this.hdk = new HDKey();\n      this.accounts = [];\n      this.page = 0;\n      this.perPage = 5;\n      this.unlockedAccount = 0;\n      this.paths = {};\n    }\n    this.hdPath = hdPath;\n  }\n\n  #normalize(buf: Buffer) {\n    return ethUtil.bufferToHex(buf).toString();\n  }\n\n  #addressFromIndex(basePath: string, i: number) {\n    const dkey = this.hdk.derive(`${basePath}/${i}`);\n    const address = ethUtil\n      .publicToAddress(dkey.publicKey, true)\n      .toString('hex');\n    return ethUtil.toChecksumAddress(`0x${address}`);\n  }\n\n  #pathFromAddress(address: string) {\n    const checksummedAddress = ethUtil.toChecksumAddress(address);\n    let index = this.paths[checksummedAddress];\n    if (typeof index === 'undefined') {\n      for (let i = 0; i < MAX_INDEX; i++) {\n        if (checksummedAddress === this.#addressFromIndex(pathBase, i)) {\n          index = i;\n          break;\n        }\n      }\n    }\n\n    if (typeof index === 'undefined') {\n      throw new Error('Unknown address');\n    }\n    return `${this.hdPath}/${index}`;\n  }\n}\n"]}
\ No newline at end of file
diff --git a/package.json b/package.json
index 88f0450d3a578cdf6be1cd43c7bb2e09cd5a72e8..c8d0dfe2282941ec44a316042d6861380bf75cb5 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
-  "name": "eth-trezor-keyring",
-  "version": "0.10.0",
+  "name": "@metamask/eth-trezor-keyring",
+  "version": "1.0.0",
   "description": "A MetaMask compatible keyring, for trezor hardware wallets",
   "keywords": [
     "ethereum",
@@ -18,37 +18,58 @@
   },
   "license": "ISC",
   "author": "Bruno Barbieri",
-  "main": "index.js",
+  "main": "dist/index.js",
+  "types": "dist/index.d.ts",
   "files": [
-    "index.js"
+    "dist/"
   ],
   "scripts": {
-    "setup": "yarn install && yarn allow-scripts",
-    "test": "mocha",
+    "build": "tsc --project tsconfig.build.json",
+    "build:clean": "rimraf dist && yarn build",
+    "build:docs": "typedoc",
+    "lint": "yarn lint:eslint && yarn lint:misc --check && yarn lint:dependencies",
+    "lint:dependencies": "depcheck",
     "lint:eslint": "eslint . --cache --ext js,ts",
-    "lint:misc": "prettier '**/*.json' '**/*.md' '!CHANGELOG.md' '**/*.yml' --ignore-path .gitignore",
-    "lint": "yarn lint:eslint && yarn lint:misc --check",
-    "lint:fix": "yarn lint:eslint --fix && yarn lint:misc --write"
+    "lint:fix": "yarn lint:eslint --fix && yarn lint:misc --write && yarn lint:dependencies",
+    "lint:misc": "prettier '**/*.json' '**/*.md' '!CHANGELOG.md' '**/*.yml' '!.yarnrc.yml' --ignore-path .gitignore --no-error-on-unmatched-pattern",
+    "prepack": "./scripts/prepack.sh",
+    "test": "mocha -r ts-node/register src/**/*.ts"
   },
   "resolutions": {
+    "@trezor/connect@9.0.6": "patch:@trezor/connect@npm%3A9.0.6#./.yarn/patches/@trezor-connect-npm-9.0.6-37abefdc3e.patch",
+    "@types/web": "0.0.69",
     "mocha/mkdirp": "^0.5.1"
   },
   "dependencies": {
-    "@ethereumjs/tx": "^3.2.1",
-    "@metamask/eth-sig-util": "^4.0.0",
-    "ethereumjs-util": "^7.0.9",
-    "hdkey": "0.8.0",
-    "trezor-connect": "8.2.6-extended"
+    "@ethereumjs/tx": "^4.0.0",
+    "@ethereumjs/util": "^8.0.0",
+    "@metamask/eth-sig-util": "^5.0.2",
+    "@metamask/utils": "^4.0.0",
+    "@trezor/connect-plugin-ethereum": "^9.0.1",
+    "@trezor/connect-web": "^9.0.6",
+    "hdkey": "0.8.0"
   },
   "devDependencies": {
-    "@ethereumjs/common": "^2.4.0",
-    "@lavamoat/allow-scripts": "^1.0.6",
-    "@metamask/auto-changelog": "^2.3.0",
+    "@ethereumjs/common": "^3.0.0",
+    "@lavamoat/allow-scripts": "^2.3.0",
+    "@metamask/auto-changelog": "^3.0.0",
     "@metamask/eslint-config": "^8.0.0",
     "@metamask/eslint-config-mocha": "^8.0.0",
     "@metamask/eslint-config-nodejs": "^8.0.0",
+    "@metamask/eslint-config-typescript": "^8.0.0",
+    "@types/chai": "^4.3.4",
+    "@types/chai-spies": "^1.0.3",
+    "@types/ethereumjs-tx": "^1.0.1",
+    "@types/hdkey": "^2.0.1",
+    "@types/mocha": "^5.0.0",
+    "@types/node": "^14.0.0",
+    "@types/sinon": "^9.0.10",
+    "@types/w3c-web-usb": "^1.0.6",
+    "@typescript-eslint/eslint-plugin": "^5.43.0",
+    "@typescript-eslint/parser": "^5.43.0",
     "chai": "^4.1.2",
     "chai-spies": "^1.0.0",
+    "depcheck": "^1.4.3",
     "eslint": "^7.26.0",
     "eslint-config-prettier": "^8.3.0",
     "eslint-plugin-import": "^2.22.1",
@@ -59,10 +80,19 @@
     "mocha": "^5.0.4",
     "prettier": "^2.3.0",
     "prettier-plugin-packagejson": "^2.2.12",
-    "sinon": "^9.2.3"
+    "rimraf": "^4.1.2",
+    "sinon": "^9.2.3",
+    "ts-node": "^10.7.0",
+    "typedoc": "^0.23.15",
+    "typescript": "~4.8.4"
   },
+  "packageManager": "yarn@3.3.1",
   "engines": {
-    "node": ">=12.0.0"
+    "node": ">=14.0.0"
+  },
+  "publishConfig": {
+    "access": "public",
+    "registry": "https://registry.npmjs.org/"
   },
   "lavamoat": {
     "allowScripts": {
@@ -72,7 +102,21 @@
       "core-js": false,
       "blake-hash": false,
       "tiny-secp256k1": false,
-      "protobufjs": false
+      "protobufjs": false,
+      "ethereumjs-tx>ethereumjs-util>keccak": false,
+      "ethereumjs-util>ethereum-cryptography>keccak": false,
+      "ethereumjs-util>ethereum-cryptography>secp256k1": false,
+      "hdkey>secp256k1": false,
+      "trezor-connect>@trezor/transport>protobufjs": false,
+      "trezor-connect>@trezor/utxo-lib>blake-hash": false,
+      "trezor-connect>@trezor/utxo-lib>tiny-secp256k1": false,
+      "@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs": false,
+      "@trezor/connect-web>@trezor/connect>@trezor/utxo-lib>blake-hash": false,
+      "@trezor/connect-web>@trezor/connect>@trezor/utxo-lib>tiny-secp256k1": false,
+      "@ethereumjs/tx>ethereumjs-util>ethereum-cryptography>keccak": false,
+      "@ethereumjs/tx>ethereumjs-util>ethereum-cryptography>secp256k1": false,
+      "ethereumjs-tx>ethereumjs-util>ethereum-cryptography>keccak": false,
+      "ethereumjs-tx>ethereumjs-util>ethereum-cryptography>secp256k1": false
     }
   }
 }
diff --git a/src/index.ts b/src/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8498ab8366bd318cbae885539aab415d110192a4
--- /dev/null
+++ b/src/index.ts
@@ -0,0 +1,3 @@
+export * from './trezor-keyring';
+export * from './trezor-bridge';
+export * from './trezor-connect-bridge';
diff --git a/src/trezor-bridge.ts b/src/trezor-bridge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3d7c1b7bbc76fc22892ab9c4c41131b9a7342341
--- /dev/null
+++ b/src/trezor-bridge.ts
@@ -0,0 +1,43 @@
+import type {
+  ConnectSettings,
+  EthereumSignedTx,
+  Manifest,
+  PROTO,
+  Response,
+  Params,
+  EthereumSignMessage,
+  EthereumSignTransaction,
+  EthereumSignTypedDataTypes,
+  EthereumSignTypedHash,
+} from '@trezor/connect-web';
+
+export interface TrezorBridge {
+  model?: string;
+
+  init(
+    settings: {
+      manifest: Manifest;
+    } & Partial<ConnectSettings>,
+  ): Promise<void>;
+
+  dispose(): Promise<void>;
+
+  // TrezorConnect.getPublicKey has two overloads
+  // It is not possible to extract them from the library using utility types
+  getPublicKey(params: {
+    path: string;
+    coin: string;
+  }): Response<{ publicKey: string; chainCode: string }>;
+
+  ethereumSignTransaction(
+    params: Params<EthereumSignTransaction>,
+  ): Response<EthereumSignedTx>;
+
+  ethereumSignMessage(
+    params: Params<EthereumSignMessage>,
+  ): Response<PROTO.MessageSignature>;
+
+  ethereumSignTypedData(
+    params: Params<EthereumSignTypedHash<EthereumSignTypedDataTypes>>,
+  ): Response<PROTO.EthereumTypedDataSignature>;
+}
diff --git a/src/trezor-connect-bridge.test.ts b/src/trezor-connect-bridge.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6423df93ccab86a06a6aadbc3cf259c3b23c3c5e
--- /dev/null
+++ b/src/trezor-connect-bridge.test.ts
@@ -0,0 +1,130 @@
+import * as sinon from 'sinon';
+import TrezorConnect, { DEVICE_EVENT } from '@trezor/connect-web';
+
+import { TrezorConnectBridge } from './trezor-connect-bridge';
+import { TrezorBridge } from './trezor-bridge';
+import { TREZOR_CONNECT_METAMASK_MANIFEST } from './trezor-keyring';
+
+describe('TrezorConnectBridge', function () {
+  let bridge: TrezorBridge;
+
+  beforeEach(function () {
+    bridge = new TrezorConnectBridge();
+  });
+
+  afterEach(function () {
+    sinon.restore();
+  });
+
+  describe('init', function () {
+    it('sets the event listener and calls init', async function () {
+      const onStub = sinon.stub(TrezorConnect, 'on');
+      const initStub = sinon.stub(TrezorConnect, 'init');
+
+      await bridge.init({
+        manifest: TREZOR_CONNECT_METAMASK_MANIFEST,
+        lazyLoad: true,
+      });
+
+      sinon.assert.calledOnce(onStub);
+      sinon.assert.calledWithExactly(
+        onStub,
+        DEVICE_EVENT as any,
+        sinon.match.func,
+      );
+
+      sinon.assert.calledOnce(initStub);
+      sinon.assert.calledWithExactly(initStub, {
+        manifest: TREZOR_CONNECT_METAMASK_MANIFEST,
+        lazyLoad: true,
+      });
+    });
+  });
+
+  describe('dispose', function () {
+    it('calls dispose', async function () {
+      const disposeStub = sinon.stub(TrezorConnect, 'dispose');
+
+      await bridge.dispose();
+
+      sinon.assert.calledOnce(disposeStub);
+      sinon.assert.calledWithExactly(disposeStub);
+    });
+  });
+
+  describe('getPublicKey', function () {
+    it('calls getPublicKey', async function () {
+      const getPublicKeyStub = sinon.stub(TrezorConnect, 'getPublicKey');
+
+      const params = {
+        path: `m/44'/60'/0'/0`,
+        coin: 'ETH',
+      } as any;
+      await bridge.getPublicKey(params);
+
+      sinon.assert.calledOnce(getPublicKeyStub);
+      sinon.assert.calledWithExactly(getPublicKeyStub, params);
+    });
+  });
+
+  describe('ethereumSignTransaction', function () {
+    it('calls ethereumSignTransaction', async function () {
+      const ethereumSignTransactionStub = sinon.stub(
+        TrezorConnect,
+        'ethereumSignTransaction',
+      );
+
+      const params: any = {
+        path: `m/44'/60'/0'/0`,
+        transaction: {
+          chainId: 1,
+          to: '0x0',
+        },
+      };
+      await bridge.ethereumSignTransaction(params);
+
+      sinon.assert.calledOnce(ethereumSignTransactionStub);
+      sinon.assert.calledWithExactly(ethereumSignTransactionStub, params);
+    });
+  });
+
+  describe('ethereumSignMessage', function () {
+    it('calls ethereumSignMessage', async function () {
+      const ethereumSignMessageStub = sinon.stub(
+        TrezorConnect,
+        'ethereumSignMessage',
+      );
+
+      const params = {
+        path: `m/44'/60'/0'/0`,
+        message: '',
+        hex: true,
+      };
+      await bridge.ethereumSignMessage(params);
+
+      sinon.assert.calledOnce(ethereumSignMessageStub);
+      sinon.assert.calledWithExactly(ethereumSignMessageStub, params);
+    });
+  });
+
+  describe('ethereumSignTypedData', function () {
+    it('calls ethereumSignTypedData', async function () {
+      const ethereumSignTypedDataStub = sinon.stub(
+        TrezorConnect,
+        'ethereumSignTypedData',
+      );
+
+      const params = {
+        path: `m/44'/60'/0'/0`,
+        data: {},
+        metamask_v4_compat: true,
+        domain_separator_hash: '',
+        message_hash: '',
+      } as any;
+      await bridge.ethereumSignTypedData(params);
+
+      sinon.assert.calledOnce(ethereumSignTypedDataStub);
+      sinon.assert.calledWithExactly(ethereumSignTypedDataStub, params);
+    });
+  });
+});
diff --git a/src/trezor-connect-bridge.ts b/src/trezor-connect-bridge.ts
new file mode 100644
index 0000000000000000000000000000000000000000..22062a4c15d810672d2d43da8651853894d4a686
--- /dev/null
+++ b/src/trezor-connect-bridge.ts
@@ -0,0 +1,57 @@
+import TrezorConnect, { DEVICE_EVENT, DEVICE } from '@trezor/connect-web';
+import type {
+  Manifest,
+  ConnectSettings,
+  EthereumSignTransaction,
+  Params,
+  EthereumSignMessage,
+  EthereumSignTypedDataTypes,
+  EthereumSignTypedHash,
+} from '@trezor/connect-web';
+import type { TrezorBridge } from './trezor-bridge';
+
+export class TrezorConnectBridge implements TrezorBridge {
+  model?: string;
+
+  init(
+    settings: {
+      manifest: Manifest;
+    } & Partial<ConnectSettings>,
+  ) {
+    TrezorConnect.on(DEVICE_EVENT, (event) => {
+      if (event.type !== DEVICE.CONNECT) {
+        return;
+      }
+
+      this.model = event.payload.features?.model;
+    });
+
+    return TrezorConnect.init(settings);
+  }
+
+  dispose() {
+    // This removes the Trezor Connect iframe from the DOM
+    // This method is not well documented, but the code it calls can be seen
+    // here: https://github.com/trezor/connect/blob/dec4a56af8a65a6059fb5f63fa3c6690d2c37e00/src/js/iframe/builder.js#L181
+    TrezorConnect.dispose();
+    return Promise.resolve();
+  }
+
+  getPublicKey(params: { path: string; coin: string }) {
+    return TrezorConnect.getPublicKey(params);
+  }
+
+  ethereumSignTransaction(params: Params<EthereumSignTransaction>) {
+    return TrezorConnect.ethereumSignTransaction(params);
+  }
+
+  ethereumSignMessage(params: Params<EthereumSignMessage>) {
+    return TrezorConnect.ethereumSignMessage(params);
+  }
+
+  ethereumSignTypedData(
+    params: Params<EthereumSignTypedHash<EthereumSignTypedDataTypes>>,
+  ) {
+    return TrezorConnect.ethereumSignTypedData(params);
+  }
+}
diff --git a/src/trezor-keyring.test.ts b/src/trezor-keyring.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3841c4a66bab63be563156d8de59d8717289bd77
--- /dev/null
+++ b/src/trezor-keyring.test.ts
@@ -0,0 +1,770 @@
+import { strict as assert } from 'assert';
+import chai from 'chai';
+import spies from 'chai-spies';
+import * as sinon from 'sinon';
+
+import EthereumTx from 'ethereumjs-tx';
+import HDKey from 'hdkey';
+import {
+  TypedTransaction,
+  TransactionFactory,
+  FeeMarketEIP1559Transaction,
+} from '@ethereumjs/tx';
+import { Common, Chain, Hardfork } from '@ethereumjs/common';
+
+import { Address } from '@ethereumjs/util';
+import { SignTypedDataVersion } from '@metamask/eth-sig-util';
+import { TrezorKeyring, TREZOR_CONNECT_METAMASK_MANIFEST } from './trezor-keyring';
+import { TrezorBridge } from './trezor-bridge';
+
+const { expect } = chai;
+
+const fakeAccounts = [
+  '0xF30952A1c534CDE7bC471380065726fa8686dfB3',
+  '0x44fe3Cf56CaF651C4bD34Ae6dbcffa34e9e3b84B',
+  '0x8Ee3374Fa705C1F939715871faf91d4348D5b906',
+  '0xEF69e24dE9CdEe93C4736FE29791E45d5D4CFd6A',
+  '0xC668a5116A045e9162902795021907Cb15aa2620',
+  '0xbF519F7a6D8E72266825D770C60dbac55a3baeb9',
+  '0x0258632Fe2F91011e06375eB0E6f8673C0463204',
+  '0x4fC1700C0C61980aef0Fb9bDBA67D8a25B5d4335',
+  '0xeEC5D417152aE295c047FB0B0eBd7c7090dDedEb',
+  '0xd3f978B9eEEdB68A38CF252B3779afbeb3623fDf',
+  '0xd819fE2beD53f44825F66873a159B687736d3092',
+  '0xE761dA62f053ad9eE221d325657535991Ab659bD',
+  '0xd4F1686961642340a80334b5171d85Bbd390c691',
+  '0x6772C4B1E841b295960Bb4662dceD9bb71726357',
+  '0x41bEAD6585eCA6c79B553Ca136f0DFA78A006899',
+] as const;
+
+const fakeXPubKey =
+  'xpub6FnCn6nSzZAw5Tw7cgR9bi15UV96gLZhjDstkXXxvCLsUXBGXPdSnLFbdpq8p9HmGsApME5hQTZ3emM2rnY5agb9rXpVGyy3bdW6EEgAtqt';
+const fakeHdKey = HDKey.fromExtendedKey(fakeXPubKey);
+const fakeTx = new EthereumTx({
+  nonce: '0x00',
+  gasPrice: '0x09184e72a000',
+  gasLimit: '0x2710',
+  to: '0x0000000000000000000000000000000000000000',
+  value: '0x00',
+  data: '0x7f7465737432000000000000000000000000000000000000000000000000000000600057',
+  // EIP 155 chainId - mainnet: 1, ropsten: 3
+  chainId: 1,
+});
+
+const common = new Common({ chain: 'mainnet' });
+const commonEIP1559 = new Common({
+  chain: Chain.Mainnet,
+  hardfork: Hardfork.London,
+});
+const newFakeTx = TransactionFactory.fromTxData(
+  {
+    nonce: '0x00',
+    gasPrice: '0x09184e72a000',
+    gasLimit: '0x2710',
+    to: '0x0000000000000000000000000000000000000000',
+    value: '0x00',
+    data: '0x7f7465737432000000000000000000000000000000000000000000000000000000600057',
+  },
+  { common, freeze: false },
+);
+
+const contractDeploymentFakeTx = TransactionFactory.fromTxData(
+  {
+    nonce: '0x00',
+    gasPrice: '0x09184e72a000',
+    gasLimit: '0x2710',
+    value: '0x00',
+    data: '0x7f7465737432000000000000000000000000000000000000000000000000000000600057',
+  },
+  { common, freeze: false },
+);
+
+const fakeTypeTwoTx = FeeMarketEIP1559Transaction.fromTxData(
+  {
+    nonce: '0x00',
+    maxFeePerGas: '0x19184e72a000',
+    maxPriorityFeePerGas: '0x09184e72a000',
+    gasLimit: '0x2710',
+    to: '0x0000000000000000000000000000000000000000',
+    value: '0x00',
+    data: '0x7f7465737432000000000000000000000000000000000000000000000000000000600057',
+    type: 2,
+    v: '0x01',
+  },
+  { common: commonEIP1559, freeze: false },
+);
+
+chai.use(spies);
+
+describe('TrezorKeyring', function () {
+  let keyring: TrezorKeyring;
+  let bridge: TrezorBridge;
+
+  beforeEach(async function () {
+    bridge = {} as TrezorBridge;
+    keyring = new TrezorKeyring({ bridge });
+    keyring.hdk = fakeHdKey;
+  });
+
+  afterEach(function () {
+    sinon.restore();
+  });
+
+  describe('Keyring.type', function () {
+    it('is a class property that returns the type string.', function () {
+      const { type } = TrezorKeyring;
+      assert.equal(typeof type, 'string');
+    });
+
+    it('returns the correct value', function () {
+      const { type } = keyring;
+      const correct = TrezorKeyring.type;
+      assert.equal(type, correct);
+    });
+  });
+
+  describe('constructor', function () {
+    it('constructs', async function () {
+      const keyringInstance = new TrezorKeyring({ bridge });
+      const accounts = await keyringInstance.getAccounts();
+
+      assert.equal(typeof keyringInstance, 'object');
+      assert.equal(Array.isArray(accounts), true);
+    });
+
+    it('throws if a bridge is not provided', async function () {
+      let error: unknown = null;
+
+      try {
+        new TrezorKeyring({ bridge: undefined as unknown as TrezorBridge });
+      } catch (e) {
+        error = e;
+      }
+
+      expect(error).to.be.an.instanceof(Error);
+      expect((error as Error).toString()).to.contain(
+        'Bridge is a required dependency for the keyring',
+      );
+    });
+  });
+
+  describe('init', function () {
+    it('initialises the bridge', async function () {
+      const initStub = sinon.stub().resolves();
+      bridge.init = initStub;
+
+      await keyring.init();
+
+      sinon.assert.calledOnce(initStub);
+      sinon.assert.calledWithExactly(initStub, {
+        manifest: TREZOR_CONNECT_METAMASK_MANIFEST,
+        lazyLoad: true,
+      });
+    });
+  });
+
+  describe('dispose', function () {
+    it('calls dispose on bridge', async function () {
+      const disposeStub = sinon.stub().resolves();
+      bridge.dispose = disposeStub;
+
+      await keyring.dispose();
+
+      sinon.assert.calledOnce(disposeStub);
+      sinon.assert.calledWithExactly(disposeStub);
+    });
+  });
+
+  describe('serialize', function () {
+    it('serializes an instance', function (done) {
+      keyring.serialize().then((output) => {
+        assert.equal(output.page, 0);
+        assert.equal(output.hdPath, `m/44'/60'/0'/0`);
+        assert.equal(Array.isArray(output.accounts), true);
+        assert.equal(output.accounts.length, 0);
+        done();
+      });
+    });
+  });
+
+  describe('deserialize', function () {
+    it('serializes what it deserializes', function (done) {
+      const someHdPath = `m/44'/60'/0'/1`;
+      keyring
+        .deserialize({
+          page: 10,
+          hdPath: someHdPath,
+          accounts: [],
+        })
+        .then(async () => {
+          return keyring.serialize();
+        })
+        .then((serialized) => {
+          assert.equal(serialized.accounts.length, 0, 'restores 0 accounts');
+          assert.equal(serialized.page, 10, 'restores page');
+          assert.equal(serialized.hdPath, someHdPath, 'restores hdPath');
+          done();
+        });
+    });
+  });
+
+  describe('isUnlocked', function () {
+    it('should return true if we have a public key', function () {
+      assert.equal(keyring.isUnlocked(), true);
+    });
+  });
+
+  describe('unlock', function () {
+    it('should resolve if we have a public key', function (done) {
+      keyring.unlock().then((_) => {
+        done();
+      });
+    });
+
+    it('should call TrezorConnect.getPublicKey if we dont have a public key', async function () {
+      const getPublicKeyStub = sinon.stub().resolves();
+      bridge.getPublicKey = getPublicKeyStub;
+
+      keyring.hdk = new HDKey();
+      try {
+        await keyring.unlock();
+      } catch (e) {
+        // Since we only care about ensuring our function gets called,
+        // we want to ignore warnings due to stub data
+      }
+
+      sinon.assert.calledOnce(getPublicKeyStub);
+      sinon.assert.calledWithExactly(getPublicKeyStub, {
+        path: `m/44'/60'/0'/0`,
+        coin: 'ETH',
+      });
+    });
+  });
+
+  describe('setAccountToUnlock', function () {
+    it('should set unlockedAccount', function () {
+      keyring.setAccountToUnlock(3);
+      assert.equal(keyring.unlockedAccount, 3);
+    });
+  });
+
+  describe('addAccounts', function () {
+    describe('with no arguments', function () {
+      it('returns a single account', function (done) {
+        keyring.setAccountToUnlock(0);
+        keyring.addAccounts().then((accounts) => {
+          assert.equal(accounts.length, 1);
+          done();
+        });
+      });
+
+      it('returns the custom accounts desired', async function () {
+        keyring.setAccountToUnlock(0);
+        await keyring.addAccounts();
+        keyring.setAccountToUnlock(2);
+        const accounts = await keyring.addAccounts();
+        assert.equal(accounts[0], fakeAccounts[0]);
+        assert.equal(accounts[1], fakeAccounts[2]);
+      });
+    });
+
+    describe('with a numeric argument', function () {
+      it('returns that number of accounts', function (done) {
+        keyring.setAccountToUnlock(0);
+        keyring.addAccounts(5).then((accounts) => {
+          assert.equal(accounts.length, 5);
+          done();
+        });
+      });
+
+      it('returns the expected accounts', function (done) {
+        keyring.setAccountToUnlock(0);
+        keyring.addAccounts(3).then((accounts) => {
+          assert.equal(accounts[0], fakeAccounts[0]);
+          assert.equal(accounts[1], fakeAccounts[1]);
+          assert.equal(accounts[2], fakeAccounts[2]);
+          done();
+        });
+      });
+    });
+  });
+
+  describe('removeAccount', function () {
+    describe('if the account exists', function () {
+      it('should remove that account', function (done) {
+        keyring.setAccountToUnlock(0);
+        keyring.addAccounts().then(async (accounts) => {
+          assert.equal(accounts.length, 1);
+          keyring.removeAccount(fakeAccounts[0]);
+          const accountsAfterRemoval = await keyring.getAccounts();
+          assert.equal(accountsAfterRemoval.length, 0);
+          done();
+        });
+      });
+
+      it('should remove only the account requested', async function () {
+        keyring.setAccountToUnlock(0);
+        await keyring.addAccounts();
+        keyring.setAccountToUnlock(1);
+        await keyring.addAccounts();
+
+        let accounts = await keyring.getAccounts();
+        assert.equal(accounts.length, 2);
+
+        keyring.removeAccount(fakeAccounts[0]);
+        accounts = await keyring.getAccounts();
+
+        assert.equal(accounts.length, 1);
+        assert.equal(accounts[0], fakeAccounts[1]);
+      });
+    });
+
+    describe('if the account does not exist', function () {
+      it('should throw an error', function () {
+        const unexistingAccount = '0x0000000000000000000000000000000000000000';
+        expect(() => {
+          keyring.removeAccount(unexistingAccount);
+        }).to.throw(`Address ${unexistingAccount} not found in this keyring`);
+      });
+    });
+  });
+
+  describe('getFirstPage', function () {
+    it('should set the currentPage to 1', async function () {
+      await keyring.getFirstPage();
+      assert.equal(keyring.page, 1);
+    });
+
+    it('should return the list of accounts for current page', async function () {
+      const accounts = await keyring.getFirstPage();
+
+      expect(accounts.length).to.equal(keyring.perPage);
+      expect(accounts[0]?.address, fakeAccounts[0]);
+      expect(accounts[1]?.address, fakeAccounts[1]);
+      expect(accounts[2]?.address, fakeAccounts[2]);
+      expect(accounts[3]?.address, fakeAccounts[3]);
+      expect(accounts[4]?.address, fakeAccounts[4]);
+    });
+  });
+
+  describe('getNextPage', function () {
+    it('should return the list of accounts for current page', async function () {
+      const accounts = await keyring.getNextPage();
+      expect(accounts.length).to.equal(keyring.perPage);
+      expect(accounts[0]?.address, fakeAccounts[0]);
+      expect(accounts[1]?.address, fakeAccounts[1]);
+      expect(accounts[2]?.address, fakeAccounts[2]);
+      expect(accounts[3]?.address, fakeAccounts[3]);
+      expect(accounts[4]?.address, fakeAccounts[4]);
+    });
+
+    it('should be able to advance to the next page', async function () {
+      // manually advance 1 page
+      await keyring.getNextPage();
+
+      const accounts = await keyring.getNextPage();
+      expect(accounts.length).to.equal(keyring.perPage);
+      expect(accounts[0]?.address, fakeAccounts[keyring.perPage + 0]);
+      expect(accounts[1]?.address, fakeAccounts[keyring.perPage + 1]);
+      expect(accounts[2]?.address, fakeAccounts[keyring.perPage + 2]);
+      expect(accounts[3]?.address, fakeAccounts[keyring.perPage + 3]);
+      expect(accounts[4]?.address, fakeAccounts[keyring.perPage + 4]);
+    });
+  });
+
+  describe('getPreviousPage', function () {
+    it('should return the list of accounts for current page', async function () {
+      // manually advance 1 page
+      await keyring.getNextPage();
+      const accounts = await keyring.getPreviousPage();
+
+      expect(accounts.length).to.equal(keyring.perPage);
+      expect(accounts[0]?.address, fakeAccounts[0]);
+      expect(accounts[1]?.address, fakeAccounts[1]);
+      expect(accounts[2]?.address, fakeAccounts[2]);
+      expect(accounts[3]?.address, fakeAccounts[3]);
+      expect(accounts[4]?.address, fakeAccounts[4]);
+    });
+
+    it('should be able to go back to the previous page', async function () {
+      // manually advance 1 page
+      await keyring.getNextPage();
+      const accounts = await keyring.getPreviousPage();
+
+      expect(accounts.length).to.equal(keyring.perPage);
+      expect(accounts[0]?.address, fakeAccounts[0]);
+      expect(accounts[1]?.address, fakeAccounts[1]);
+      expect(accounts[2]?.address, fakeAccounts[2]);
+      expect(accounts[3]?.address, fakeAccounts[3]);
+      expect(accounts[4]?.address, fakeAccounts[4]);
+    });
+  });
+
+  describe('getAccounts', function () {
+    const accountIndex = 5;
+    let accounts: string[] = [];
+    beforeEach(async function () {
+      keyring.setAccountToUnlock(accountIndex);
+      await keyring.addAccounts();
+      accounts = await keyring.getAccounts();
+    });
+
+    it('returns an array of accounts', function () {
+      assert.equal(Array.isArray(accounts), true);
+      assert.equal(accounts.length, 1);
+    });
+
+    it('returns the expected', function () {
+      const expectedAccount = fakeAccounts[accountIndex];
+      assert.equal(accounts[0], expectedAccount);
+    });
+  });
+
+  describe('signTransaction', function () {
+    it('should pass serialized transaction to trezor and return signed tx', async function () {
+      const ethereumSignTransactionStub = sinon.stub().resolves({
+        success: true,
+        payload: { v: '0x1', r: '0x0', s: '0x0' },
+      });
+      bridge.ethereumSignTransaction = ethereumSignTransactionStub;
+
+      sinon.stub(fakeTx, 'verifySignature').callsFake(() => true);
+      sinon
+        .stub(fakeTx, 'getSenderAddress')
+        .callsFake(() => Address.fromString(fakeAccounts[0]).toBuffer());
+
+      const returnedTx = await keyring.signTransaction(fakeAccounts[0], fakeTx);
+      // assert that the v,r,s values got assigned to tx.
+      assert.ok(returnedTx.v);
+      assert.ok(returnedTx.r);
+      assert.ok(returnedTx.s);
+      // ensure we get a older version transaction back
+      assert.equal((returnedTx as EthereumTx).getChainId(), 1);
+      assert.equal((returnedTx as TypedTransaction).common, undefined);
+      sinon.assert.calledOnce(ethereumSignTransactionStub);
+    });
+
+    it('should pass serialized newer transaction to trezor and return signed tx', async function () {
+      sinon.stub(TransactionFactory, 'fromTxData').callsFake(() => {
+        // without having a private key/public key pair in this test, we have
+        // mock out this method and return the original tx because we can't
+        // replicate r and s values without the private key.
+        return newFakeTx;
+      });
+
+      const ethereumSignTransactionStub = sinon.stub().resolves({
+        success: true,
+        payload: { v: '0x25', r: '0x0', s: '0x0' },
+      });
+      bridge.ethereumSignTransaction = ethereumSignTransactionStub;
+
+      sinon
+        .stub(newFakeTx, 'getSenderAddress')
+        .callsFake(() => Address.fromString(fakeAccounts[0]));
+      sinon.stub(newFakeTx, 'verifySignature').callsFake(() => true);
+
+      const returnedTx = await keyring.signTransaction(
+        fakeAccounts[0],
+        newFakeTx,
+      );
+      // ensure we get a new version transaction back
+      // eslint-disable-next-line @typescript-eslint/unbound-method
+      assert.equal((returnedTx as EthereumTx).getChainId, undefined);
+      assert.equal(
+        (returnedTx as TypedTransaction).common.chainId().toString(16),
+        '1',
+      );
+      sinon.assert.calledOnce(ethereumSignTransactionStub);
+    });
+
+    it('should pass serialized contract deployment transaction to trezor and return signed tx', async function () {
+      sinon.stub(TransactionFactory, 'fromTxData').callsFake(() => {
+        // without having a private key/public key pair in this test, we have
+        // mock out this method and return the original tx because we can't
+        // replicate r and s values without the private key.
+        return contractDeploymentFakeTx;
+      });
+
+      const ethereumSignTransactionStub = sinon.stub().resolves({
+        success: true,
+        payload: { v: '0x25', r: '0x0', s: '0x0' },
+      });
+      bridge.ethereumSignTransaction = ethereumSignTransactionStub;
+
+      sinon
+        .stub(contractDeploymentFakeTx, 'getSenderAddress')
+        .callsFake(() => Address.fromString(fakeAccounts[0]));
+
+      sinon
+        .stub(contractDeploymentFakeTx, 'verifySignature')
+        .callsFake(() => true);
+
+      const returnedTx = await keyring.signTransaction(
+        fakeAccounts[0],
+        contractDeploymentFakeTx,
+      );
+      // ensure we get a new version transaction back
+      // eslint-disable-next-line @typescript-eslint/unbound-method
+      assert.equal((returnedTx as EthereumTx).getChainId, undefined);
+      assert.equal(
+        (returnedTx as TypedTransaction).common.chainId().toString(16),
+        '1',
+      );
+      sinon.assert.calledOnce(ethereumSignTransactionStub);
+      sinon.assert.calledWithExactly(ethereumSignTransactionStub, {
+        path: `m/44'/60'/0'/0/0`,
+        transaction: {
+          ...contractDeploymentFakeTx.toJSON(),
+          to: '0x',
+          chainId: 1,
+        },
+      });
+    });
+
+    it('should pass correctly encoded EIP1559 transaction to trezor and return signed tx', async function () {
+      // Copied from @MetaMask/eth-ledger-bridge-keyring
+      // Generated by signing fakeTypeTwoTx with an unknown private key
+      const expectedRSV = {
+        v: '0x0',
+        r: '0x5ffb3adeaec80e430e7a7b02d95c5108b6f09a0bdf3cf69869dc1b38d0fb8d3a',
+        s: '0x28b234a5403d31564e18258df84c51a62683e3f54fa2b106fdc1a9058006a112',
+      };
+      // Override actual address of 0x391535104b6e0Ea6dDC2AD0158aB3Fbd7F04ed1B
+      const fromTxDataStub = sinon.stub(TransactionFactory, 'fromTxData');
+      fromTxDataStub.callsFake((...args) => {
+        const tx = fromTxDataStub.wrappedMethod(...args);
+        sinon
+          .stub(tx, 'getSenderAddress')
+          .returns(Address.fromString(fakeAccounts[0]));
+        return tx;
+      });
+
+      const ethereumSignTransactionStub = sinon.stub().resolves({
+        success: true,
+        payload: expectedRSV,
+      });
+      bridge.ethereumSignTransaction = ethereumSignTransactionStub;
+
+      const returnedTx = await keyring.signTransaction(
+        fakeAccounts[0],
+        fakeTypeTwoTx,
+      );
+
+      sinon.assert.calledOnce(ethereumSignTransactionStub);
+      sinon.assert.calledWithExactly(ethereumSignTransactionStub, {
+        path: "m/44'/60'/0'/0/0",
+        transaction: {
+          chainId: 1,
+          nonce: '0x0',
+          maxPriorityFeePerGas: '0x9184e72a000',
+          maxFeePerGas: '0x19184e72a000',
+          gasLimit: '0x2710',
+          to: '0x0000000000000000000000000000000000000000',
+          value: '0x0',
+          data: '0x7f7465737432000000000000000000000000000000000000000000000000000000600057',
+          accessList: [],
+          v: '0x1',
+          r: undefined,
+          s: undefined,
+        },
+      });
+      expect(returnedTx.toJSON()).to.deep.equal({
+        ...fakeTypeTwoTx.toJSON(),
+        ...expectedRSV,
+      });
+    });
+  });
+
+  describe('signMessage', function () {
+    it('should call TrezorConnect.ethereumSignMessage', async function () {
+      const ethereumSignMessageStub = sinon.stub().resolves({});
+      bridge.ethereumSignMessage = ethereumSignMessageStub;
+
+      try {
+        await keyring.signMessage(fakeAccounts[0], 'some msg');
+      } catch (error) {
+        // Since we only care about ensuring our function gets called,
+        // we want to ignore warnings due to stub data
+      }
+
+      sinon.assert.calledOnce(ethereumSignMessageStub);
+    });
+  });
+
+  describe('signPersonalMessage', function () {
+    it('should call TrezorConnect.ethereumSignMessage', async function () {
+      const ethereumSignMessageStub = sinon.stub().resolves({});
+      bridge.ethereumSignMessage = ethereumSignMessageStub;
+
+      try {
+        await keyring.signPersonalMessage(fakeAccounts[0], 'some msg');
+      } catch (error) {
+        // Since we only care about ensuring our function gets called,
+        // we want to ignore warnings due to stub data
+      }
+
+      sinon.assert.calledOnce(ethereumSignMessageStub);
+    });
+  });
+
+  describe('signTypedData', function () {
+    it('should throw an error on signTypedData_v3 because it is not supported', async function () {
+      let error: unknown = null;
+      try {
+        await keyring.signTypedData(
+          String(null),
+          {
+            types: { EIP712Domain: [], EmptyMessage: [] },
+            primaryType: 'EmptyMessage',
+            domain: {},
+            message: {},
+          },
+          {
+            version: SignTypedDataVersion.V3,
+          },
+        );
+      } catch (e) {
+        error = e;
+      }
+
+      expect(error).to.be.an.instanceof(Error);
+      expect((error as Error).toString()).to.contain(
+        'Only version 4 of typed data signing is supported',
+      );
+    });
+
+    it('should call TrezorConnect.ethereumSignTypedData', async function () {
+      const ethereumSignTypedDataStub = sinon.stub().resolves({
+        success: true,
+        payload: { signature: '0x00', address: fakeAccounts[0] },
+      });
+      bridge.ethereumSignTypedData = ethereumSignTypedDataStub;
+
+      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
+      // @ts-ignore next-line
+      // eslint-disable-next-line no-invalid-this
+      this.timeout = 60000;
+      await keyring.signTypedData(
+        fakeAccounts[0],
+        // Message with missing data that @metamask/eth-sig-util accepts
+        {
+          types: { EIP712Domain: [], EmptyMessage: [] },
+          primaryType: 'EmptyMessage',
+          domain: {},
+          message: {},
+        },
+        { version: SignTypedDataVersion.V4 },
+      );
+
+      sinon.assert.calledOnce(ethereumSignTypedDataStub);
+      sinon.assert.calledWithExactly(ethereumSignTypedDataStub, {
+        path: "m/44'/60'/0'/0/0",
+        data: {
+          // Empty message that trezor-connect/EIP-712 spec accepts
+          types: { EIP712Domain: [], EmptyMessage: [] },
+          primaryType: 'EmptyMessage',
+          domain: {},
+          message: {},
+        },
+        // eslint-disable-next-line @typescript-eslint/naming-convention
+        metamask_v4_compat: true,
+        // eslint-disable-next-line @typescript-eslint/naming-convention
+        domain_separator_hash:
+          '6192106f129ce05c9075d319c1fa6ea9b3ae37cbd0c1ef92e2be7137bb07baa1',
+        // eslint-disable-next-line @typescript-eslint/naming-convention
+        message_hash:
+          'c9e71eb57cf9fa86ec670283b58cb15326bb6933c8d8e2ecb2c0849021b3ef42',
+      });
+    });
+  });
+
+  describe('exportAccount', function () {
+    it('should throw an error because it is not supported', async function () {
+      let error: unknown = null;
+      try {
+        await keyring.exportAccount();
+      } catch (e) {
+        error = e;
+      }
+
+      expect(error instanceof Error).to.equal(true);
+      expect((error as Error).toString(), 'Not supported on this device');
+    });
+  });
+
+  describe('forgetDevice', function () {
+    it('should clear the content of the keyring', async function () {
+      // Add an account
+      keyring.setAccountToUnlock(0);
+      await keyring.addAccounts();
+
+      // Wipe the keyring
+      keyring.forgetDevice();
+
+      const accounts = await keyring.getAccounts();
+
+      assert.equal(keyring.isUnlocked(), false);
+      assert.equal(accounts.length, 0);
+    });
+  });
+
+  describe('setHdPath', function () {
+    const initialProperties = {
+      hdPath: `m/44'/60'/0'/0` as const,
+      accounts: ['Account 1'],
+      page: 2,
+      perPage: 10,
+    };
+    const accountToUnlock = 1;
+    // eslint-disable-next-line @typescript-eslint/naming-convention
+    const mockPaths = { '0x123': 1 };
+
+    beforeEach(function () {
+      keyring.deserialize(initialProperties);
+      keyring.paths = mockPaths;
+      keyring.setAccountToUnlock(accountToUnlock.toString(16));
+    });
+
+    it('should do nothing if passed an hdPath equal to the current hdPath', async function () {
+      keyring.setHdPath(initialProperties.hdPath);
+      assert.equal(keyring.hdPath, initialProperties.hdPath);
+      assert.deepEqual(keyring.accounts, initialProperties.accounts);
+      assert.equal(keyring.page, initialProperties.page);
+      assert.equal(keyring.perPage, initialProperties.perPage);
+      assert.equal(
+        keyring.hdk.publicKey.toString('hex'),
+        fakeHdKey.publicKey.toString('hex'),
+      );
+      assert.equal(keyring.unlockedAccount, accountToUnlock);
+      assert.deepEqual(keyring.paths, mockPaths);
+    });
+
+    it('should update the hdPath and reset account and page properties if passed a new hdPath', async function () {
+      const SLIP0044TestnetPath = `m/44'/1'/0'/0`;
+
+      keyring.setHdPath(SLIP0044TestnetPath);
+
+      assert.equal(keyring.hdPath, SLIP0044TestnetPath);
+      assert.deepEqual(keyring.accounts, []);
+      assert.equal(keyring.page, 0);
+      assert.equal(keyring.perPage, 5);
+      assert.equal(keyring.hdk.publicKey, null);
+      assert.equal(keyring.unlockedAccount, 0);
+      assert.deepEqual(keyring.paths, {});
+    });
+
+    it('should throw an error if passed an unsupported hdPath', async function () {
+      const unsupportedPath = 'unsupported hdPath';
+      try {
+        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
+        // @ts-ignore next-line
+        keyring.setHdPath(unsupportedPath);
+      } catch (error) {
+        assert.equal(
+          (error as Error).message,
+          `The setHdPath method does not support setting HD Path to ${unsupportedPath}`,
+        );
+      }
+    });
+  });
+});
diff --git a/src/trezor-keyring.ts b/src/trezor-keyring.ts
new file mode 100644
index 0000000000000000000000000000000000000000..df36d309c117cb097f2a1b547a335a664866cbf8
--- /dev/null
+++ b/src/trezor-keyring.ts
@@ -0,0 +1,562 @@
+import { EventEmitter } from 'events';
+import * as ethUtil from '@ethereumjs/util';
+import HDKey from 'hdkey';
+import type {
+  EthereumTransactionEIP1559,
+  EthereumSignedTx,
+  EthereumTransaction,
+  EthereumSignTypedDataTypes,
+} from '@trezor/connect-web';
+import { TransactionFactory } from '@ethereumjs/tx';
+import type { TypedTransaction, TxData } from '@ethereumjs/tx';
+import type OldEthJsTransaction from 'ethereumjs-tx';
+import { transformTypedData } from '@trezor/connect-plugin-ethereum';
+import { TypedMessage, SignTypedDataVersion } from '@metamask/eth-sig-util';
+import { TrezorBridge } from './trezor-bridge';
+
+const hdPathString = `m/44'/60'/0'/0`;
+const SLIP0044TestnetPath = `m/44'/1'/0'/0`;
+
+const ALLOWED_HD_PATHS = {
+  [hdPathString]: true,
+  [SLIP0044TestnetPath]: true,
+} as const;
+
+const keyringType = 'Trezor Hardware';
+const pathBase = 'm';
+const MAX_INDEX = 1000;
+const DELAY_BETWEEN_POPUPS = 1000;
+export const TREZOR_CONNECT_METAMASK_MANIFEST = {
+  email: 'support@metamask.io',
+  appUrl: 'https://metamask.io',
+};
+
+export interface TrezorControllerOptions {
+  hdPath?: string;
+  accounts?: string[];
+  page?: number;
+  perPage?: number;
+}
+
+export interface TrezorControllerState {
+  hdPath: string;
+  accounts: readonly string[];
+  page: number;
+  paths: Record<string, number>;
+  perPage: number;
+  unlockedAccount: number;
+}
+
+async function wait(ms: number) {
+  return new Promise((resolve) => setTimeout(resolve, ms));
+}
+
+/**
+ * Check if the given transaction is made with ethereumjs-tx or @ethereumjs/tx
+ *
+ * Transactions built with older versions of ethereumjs-tx have a
+ * getChainId method that newer versions do not.
+ * Older versions are mutable
+ * while newer versions default to being immutable.
+ * Expected shape and type
+ * of data for v, r and s differ (Buffer (old) vs BN (new)).
+ *
+ * @param tx
+ * @returns Returns `true` if tx is an old-style ethereumjs-tx transaction.
+ */
+function isOldStyleEthereumjsTx(
+  tx: TypedTransaction | OldEthJsTransaction,
+): tx is OldEthJsTransaction {
+  return typeof (tx as OldEthJsTransaction).getChainId === 'function';
+}
+
+export class TrezorKeyring extends EventEmitter {
+  static type: string = keyringType;
+
+  readonly type: string = keyringType;
+
+  accounts: readonly string[] = [];
+
+  hdk: HDKey = new HDKey();
+
+  hdPath: string = hdPathString;
+
+  page = 0;
+
+  perPage = 5;
+
+  unlockedAccount = 0;
+
+  paths: Record<string, number> = {};
+
+  bridge: TrezorBridge;
+
+  constructor({ bridge }: { bridge: TrezorBridge }) {
+    super();
+
+    if (!bridge) {
+      throw new Error('Bridge is a required dependency for the keyring');
+    }
+
+    this.bridge = bridge;
+  }
+
+  /**
+   * Gets the model, if known.
+   * This may be `undefined` if the model hasn't been loaded yet.
+   *
+   * @returns
+   */
+  getModel(): string | undefined {
+    return this.bridge.model;
+  }
+
+  init() {
+    return this.bridge.init({
+      manifest: TREZOR_CONNECT_METAMASK_MANIFEST,
+      lazyLoad: true,
+    });
+  }
+
+  dispose() {
+    return this.bridge.dispose();
+  }
+
+  async serialize(): Promise<TrezorControllerState> {
+    return Promise.resolve({
+      hdPath: this.hdPath,
+      accounts: this.accounts,
+      page: this.page,
+      paths: this.paths,
+      perPage: this.perPage,
+      unlockedAccount: this.unlockedAccount,
+    });
+  }
+
+  async deserialize(opts: TrezorControllerOptions = {}) {
+    this.hdPath = opts.hdPath ?? hdPathString;
+    this.accounts = opts.accounts ?? [];
+    this.page = opts.page ?? 0;
+    this.perPage = opts.perPage ?? 5;
+    return Promise.resolve();
+  }
+
+  isUnlocked() {
+    return Boolean(this.hdk?.publicKey);
+  }
+
+  async unlock() {
+    if (this.isUnlocked()) {
+      return Promise.resolve('already unlocked');
+    }
+    return new Promise((resolve, reject) => {
+      this.bridge
+        .getPublicKey({
+          path: this.hdPath,
+          coin: 'ETH',
+        })
+        .then((response) => {
+          if (response.success) {
+            this.hdk.publicKey = Buffer.from(response.payload.publicKey, 'hex');
+            this.hdk.chainCode = Buffer.from(response.payload.chainCode, 'hex');
+            resolve('just unlocked');
+          } else {
+            reject(new Error(response.payload?.error || 'Unknown error'));
+          }
+        })
+        .catch((e) => {
+          reject(new Error(e?.toString() || 'Unknown error'));
+        });
+    });
+  }
+
+  setAccountToUnlock(index: number | string) {
+    this.unlockedAccount = parseInt(String(index), 10);
+  }
+
+  async addAccounts(n = 1): Promise<readonly string[]> {
+    return new Promise((resolve, reject) => {
+      this.unlock()
+        .then((_) => {
+          const from = this.unlockedAccount;
+          const to = from + n;
+
+          for (let i = from; i < to; i++) {
+            const address = this.#addressFromIndex(pathBase, i);
+            if (!this.accounts.includes(address)) {
+              this.accounts = [...this.accounts, address];
+            }
+            this.page = 0;
+          }
+          resolve(this.accounts);
+        })
+        .catch((e) => {
+          reject(e);
+        });
+    });
+  }
+
+  async getFirstPage() {
+    this.page = 0;
+    return this.#getPage(1);
+  }
+
+  async getNextPage() {
+    return this.#getPage(1);
+  }
+
+  async getPreviousPage() {
+    return this.#getPage(-1);
+  }
+
+  async #getPage(
+    increment: number,
+  ): Promise<{ address: string; balance: number | null; index: number }[]> {
+    this.page += increment;
+
+    if (this.page <= 0) {
+      this.page = 1;
+    }
+
+    return new Promise((resolve, reject) => {
+      this.unlock()
+        .then((_) => {
+          const from = (this.page - 1) * this.perPage;
+          const to = from + this.perPage;
+
+          const accounts = [];
+
+          for (let i = from; i < to; i++) {
+            const address = this.#addressFromIndex(pathBase, i);
+            accounts.push({
+              address,
+              balance: null,
+              index: i,
+            });
+            this.paths[ethUtil.toChecksumAddress(address)] = i;
+          }
+          resolve(accounts);
+        })
+        .catch((e) => {
+          reject(e);
+        });
+    });
+  }
+
+  async getAccounts() {
+    return Promise.resolve(this.accounts.slice());
+  }
+
+  removeAccount(address: string) {
+    if (
+      !this.accounts.map((a) => a.toLowerCase()).includes(address.toLowerCase())
+    ) {
+      throw new Error(`Address ${address} not found in this keyring`);
+    }
+
+    this.accounts = this.accounts.filter(
+      (a) => a.toLowerCase() !== address.toLowerCase(),
+    );
+  }
+
+  /**
+   * Signs a transaction using Trezor.
+   *
+   * Accepts either an ethereumjs-tx or @ethereumjs/tx transaction, and returns
+   * the same type.
+   *
+   * @param address - Hex string address.
+   * @param tx - Instance of either new-style or old-style ethereumjs transaction.
+   * @returns The signed transaction, an instance of either new-style or old-style
+   * ethereumjs transaction.
+   */
+  async signTransaction(
+    address: string,
+    tx: TypedTransaction | OldEthJsTransaction,
+  ) {
+    if (isOldStyleEthereumjsTx(tx)) {
+      // In this version of ethereumjs-tx we must add the chainId in hex format
+      // to the initial v value. The chainId must be included in the serialized
+      // transaction which is only communicated to ethereumjs-tx in this
+      // value. In newer versions the chainId is communicated via the 'Common'
+      // object.
+      return this.#signTransaction(
+        address,
+        // @types/ethereumjs-tx and old ethereumjs-tx versions document
+        // this function return value as Buffer, but the actual
+        // Transaction._chainId will always be a number.
+        // See https://github.com/ethereumjs/ethereumjs-tx/blob/v1.3.7/index.js#L126
+        tx.getChainId() as unknown as number,
+        tx,
+        (payload) => {
+          tx.v = Buffer.from(payload.v, 'hex');
+          tx.r = Buffer.from(payload.r, 'hex');
+          tx.s = Buffer.from(payload.s, 'hex');
+          return tx;
+        },
+      );
+    }
+    return this.#signTransaction(
+      address,
+      Number(tx.common.chainId()),
+      tx,
+      (payload) => {
+        // Because tx will be immutable, first get a plain javascript object that
+        // represents the transaction. Using txData here as it aligns with the
+        // nomenclature of ethereumjs/tx.
+        const txData: TxData = tx.toJSON();
+        // The fromTxData utility expects a type to support transactions with a type other than 0
+        txData.type = tx.type;
+        // The fromTxData utility expects v,r and s to be hex prefixed
+        txData.v = ethUtil.addHexPrefix(payload.v);
+        txData.r = ethUtil.addHexPrefix(payload.r);
+        txData.s = ethUtil.addHexPrefix(payload.s);
+        // Adopt the 'common' option from the original transaction and set the
+        // returned object to be frozen if the original is frozen.
+        return TransactionFactory.fromTxData(txData, {
+          common: tx.common,
+          freeze: Object.isFrozen(tx),
+        });
+      },
+    );
+  }
+
+  /**
+   *
+   * @param address - Hex string address.
+   * @param chainId - Chain ID
+   * @param tx - Instance of either new-style or old-style ethereumjs transaction.
+   * @param handleSigning - Converts signed transaction
+   * to the same new-style or old-style ethereumjs-tx.
+   * @returns The signed transaction, an instance of either new-style or old-style
+   * ethereumjs transaction.
+   */
+  async #signTransaction<T extends TypedTransaction | OldEthJsTransaction>(
+    address: string,
+    chainId: number,
+    tx: T,
+    handleSigning: (tx: EthereumSignedTx) => T,
+  ): Promise<T> {
+    let transaction: EthereumTransaction | EthereumTransactionEIP1559;
+    if (isOldStyleEthereumjsTx(tx)) {
+      // legacy transaction from ethereumjs-tx package has no .toJSON() function,
+      // so we need to convert to hex-strings manually manually
+      transaction = {
+        to: this.#normalize(tx.to),
+        value: this.#normalize(tx.value),
+        data: this.#normalize(tx.data),
+        chainId,
+        nonce: this.#normalize(tx.nonce),
+        gasLimit: this.#normalize(tx.gasLimit),
+        gasPrice: this.#normalize(tx.gasPrice),
+      };
+    } else {
+      // new-style transaction from @ethereumjs/tx package
+      // we can just copy tx.toJSON() for everything except chainId, which must be a number
+      transaction = {
+        ...tx.toJSON(),
+        chainId,
+        to: this.#normalize(ethUtil.toBuffer(tx.to)),
+      } as EthereumTransaction | EthereumTransactionEIP1559;
+    }
+
+    try {
+      const status = await this.unlock();
+      await wait(status === 'just unlocked' ? DELAY_BETWEEN_POPUPS : 0);
+      const response = await this.bridge.ethereumSignTransaction({
+        path: this.#pathFromAddress(address),
+        transaction,
+      });
+      if (response.success) {
+        const newOrMutatedTx = handleSigning(response.payload);
+
+        const addressSignedWith = ethUtil.toChecksumAddress(
+          ethUtil.addHexPrefix(
+            newOrMutatedTx.getSenderAddress().toString('hex'),
+          ),
+        );
+        const correctAddress = ethUtil.toChecksumAddress(address);
+        if (addressSignedWith !== correctAddress) {
+          throw new Error("signature doesn't match the right address");
+        }
+
+        return newOrMutatedTx;
+      }
+      throw new Error(response.payload?.error || 'Unknown error');
+    } catch (e) {
+      throw new Error(e?.toString() ?? 'Unknown error');
+    }
+  }
+
+  async signMessage(withAccount: string, data: string) {
+    return this.signPersonalMessage(withAccount, data);
+  }
+
+  // For personal_sign, we need to prefix the message:
+  async signPersonalMessage(withAccount: string, message: string) {
+    return new Promise((resolve, reject) => {
+      this.unlock()
+        .then((status) => {
+          setTimeout(
+            () => {
+              this.bridge
+                .ethereumSignMessage({
+                  path: this.#pathFromAddress(withAccount),
+                  message: ethUtil.stripHexPrefix(message),
+                  hex: true,
+                })
+                .then((response) => {
+                  if (response.success) {
+                    if (
+                      response.payload.address !==
+                      ethUtil.toChecksumAddress(withAccount)
+                    ) {
+                      reject(
+                        new Error('signature doesnt match the right address'),
+                      );
+                    }
+                    const signature = `0x${response.payload.signature}`;
+                    resolve(signature);
+                  } else {
+                    reject(
+                      new Error(response.payload?.error || 'Unknown error'),
+                    );
+                  }
+                })
+                .catch((e) => {
+                  reject(new Error(e?.toString() || 'Unknown error'));
+                });
+              // This is necessary to avoid popup collision
+              // between the unlock & sign trezor popups
+            },
+            status === 'just unlocked' ? DELAY_BETWEEN_POPUPS : 0,
+          );
+        })
+        .catch((e) => {
+          reject(new Error(e?.toString() || 'Unknown error'));
+        });
+    });
+  }
+
+  /**
+   * EIP-712 Sign Typed Data
+   */
+  async signTypedData(
+    address: string,
+    data: TypedMessage<EthereumSignTypedDataTypes>,
+    { version }: { version: SignTypedDataVersion },
+  ) {
+    const dataWithHashes = transformTypedData(data, version === 'V4');
+
+    // set default values for signTypedData
+    // Trezor is stricter than @metamask/eth-sig-util in what it accepts
+    const {
+      types,
+      message = {},
+      domain = {},
+      primaryType,
+      // snake_case since Trezor uses Protobuf naming conventions here
+      domain_separator_hash, // eslint-disable-line camelcase
+      message_hash, // eslint-disable-line camelcase
+    } = dataWithHashes;
+
+    // This is necessary to avoid popup collision
+    // between the unlock & sign trezor popups
+    const status = await this.unlock();
+    await wait(status === 'just unlocked' ? DELAY_BETWEEN_POPUPS : 0);
+
+    const response = await this.bridge.ethereumSignTypedData({
+      path: this.#pathFromAddress(address),
+      data: {
+        types: { ...types, EIP712Domain: types.EIP712Domain ?? [] },
+        message,
+        domain,
+        primaryType,
+      },
+      metamask_v4_compat: true, // eslint-disable-line camelcase
+      // Trezor 1 only supports blindly signing hashes
+      domain_separator_hash, // eslint-disable-line camelcase
+      message_hash: message_hash ?? '', // eslint-disable-line camelcase
+    });
+
+    if (response.success) {
+      if (ethUtil.toChecksumAddress(address) !== response.payload.address) {
+        throw new Error('signature doesnt match the right address');
+      }
+      return response.payload.signature;
+    }
+
+    throw new Error(response.payload?.error || 'Unknown error');
+  }
+
+  async exportAccount() {
+    return Promise.reject(new Error('Not supported on this device'));
+  }
+
+  forgetDevice() {
+    this.accounts = [];
+    this.hdk = new HDKey();
+    this.page = 0;
+    this.unlockedAccount = 0;
+    this.paths = {};
+  }
+
+  /**
+   * Set the HD path to be used by the keyring. Only known supported HD paths are allowed.
+   *
+   * If the given HD path is already the current HD path, nothing happens. Otherwise the new HD
+   * path is set, and the wallet state is completely reset.
+   *
+   * @throws {Error] Throws if the HD path is not supported.
+   *
+   * @param hdPath - The HD path to set.
+   */
+  setHdPath(hdPath: keyof typeof ALLOWED_HD_PATHS) {
+    if (!ALLOWED_HD_PATHS[hdPath]) {
+      throw new Error(
+        `The setHdPath method does not support setting HD Path to ${hdPath}`,
+      );
+    }
+
+    // Reset HDKey if the path changes
+    if (this.hdPath !== hdPath) {
+      this.hdk = new HDKey();
+      this.accounts = [];
+      this.page = 0;
+      this.perPage = 5;
+      this.unlockedAccount = 0;
+      this.paths = {};
+    }
+    this.hdPath = hdPath;
+  }
+
+  #normalize(buf: Buffer) {
+    return ethUtil.bufferToHex(buf).toString();
+  }
+
+  #addressFromIndex(basePath: string, i: number) {
+    const dkey = this.hdk.derive(`${basePath}/${i}`);
+    const address = ethUtil
+      .publicToAddress(dkey.publicKey, true)
+      .toString('hex');
+    return ethUtil.toChecksumAddress(`0x${address}`);
+  }
+
+  #pathFromAddress(address: string) {
+    const checksummedAddress = ethUtil.toChecksumAddress(address);
+    let index = this.paths[checksummedAddress];
+    if (typeof index === 'undefined') {
+      for (let i = 0; i < MAX_INDEX; i++) {
+        if (checksummedAddress === this.#addressFromIndex(pathBase, i)) {
+          index = i;
+          break;
+        }
+      }
+    }
+
+    if (typeof index === 'undefined') {
+      throw new Error('Unknown address');
+    }
+    return `${this.hdPath}/${index}`;
+  }
+}
