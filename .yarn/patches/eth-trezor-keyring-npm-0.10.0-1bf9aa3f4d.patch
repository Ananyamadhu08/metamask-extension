diff --git a/index.js b/index.js
index 9b76a29305d48cd36b3ffd3b17f5ecdc9be96d0d..6085ac9ad16e7bfce23c4fbdc7ef6fbcc22e8fe7 100644
--- a/index.js
+++ b/index.js
@@ -1,519 +1,8 @@
-const { EventEmitter } = require('events');
-const ethUtil = require('ethereumjs-util');
-const HDKey = require('hdkey');
-const TrezorConnect = require('trezor-connect').default;
-const { TransactionFactory } = require('@ethereumjs/tx');
-const transformTypedData = require('trezor-connect/lib/plugins/ethereum/typedData');
+const { TrezorKeyring, TREZOR_CONNECT_MANIFEST } = require('./trezor-keyring');
+const { TrezorBridgeWeb } = require('./trezor-bridge-web');
 
-const hdPathString = `m/44'/60'/0'/0`;
-const SLIP0044TestnetPath = `m/44'/1'/0'/0`;
-
-const ALLOWED_HD_PATHS = {
-  [hdPathString]: true,
-  [SLIP0044TestnetPath]: true,
-};
-
-const keyringType = 'Trezor Hardware';
-const pathBase = 'm';
-const MAX_INDEX = 1000;
-const DELAY_BETWEEN_POPUPS = 1000;
-const TREZOR_CONNECT_MANIFEST = {
-  email: 'support@metamask.io',
-  appUrl: 'https://metamask.io',
+module.exports = {
+  TREZOR_CONNECT_MANIFEST,
+  TrezorKeyring,
+  TrezorBridgeWeb,
 };
-
-function wait(ms) {
-  return new Promise((resolve) => setTimeout(resolve, ms));
-}
-
-/**
- * @typedef {import('@ethereumjs/tx').TypedTransaction} TypedTransaction
- * @typedef {InstanceType<import("ethereumjs-tx")>} OldEthJsTransaction
- */
-
-/**
- * Check if the given transaction is made with ethereumjs-tx or @ethereumjs/tx
- *
- * Transactions built with older versions of ethereumjs-tx have a
- * getChainId method that newer versions do not.
- * Older versions are mutable
- * while newer versions default to being immutable.
- * Expected shape and type
- * of data for v, r and s differ (Buffer (old) vs BN (new)).
- *
- * @param {TypedTransaction | OldEthJsTransaction} tx
- * @returns {tx is OldEthJsTransaction} Returns `true` if tx is an old-style ethereumjs-tx transaction.
- */
-function isOldStyleEthereumjsTx(tx) {
-  return typeof tx.getChainId === 'function';
-}
-
-class TrezorKeyring extends EventEmitter {
-  constructor(opts = {}) {
-    super();
-    this.type = keyringType;
-    this.accounts = [];
-    this.hdk = new HDKey();
-    this.page = 0;
-    this.perPage = 5;
-    this.unlockedAccount = 0;
-    this.paths = {};
-    this.deserialize(opts);
-
-    TrezorConnect.on('DEVICE_EVENT', (event) => {
-      if (event && event.payload && event.payload.features) {
-        this.model = event.payload.features.model;
-      }
-    });
-    TrezorConnect.init({ manifest: TREZOR_CONNECT_MANIFEST });
-  }
-
-  /**
-   * Gets the model, if known.
-   * This may be `undefined` if the model hasn't been loaded yet.
-   *
-   * @returns {"T" | "1" | undefined}
-   */
-  getModel() {
-    return this.model;
-  }
-
-  dispose() {
-    // This removes the Trezor Connect iframe from the DOM
-    // This method is not well documented, but the code it calls can be seen
-    // here: https://github.com/trezor/connect/blob/dec4a56af8a65a6059fb5f63fa3c6690d2c37e00/src/js/iframe/builder.js#L181
-    TrezorConnect.dispose();
-  }
-
-  serialize() {
-    return Promise.resolve({
-      hdPath: this.hdPath,
-      accounts: this.accounts,
-      page: this.page,
-      paths: this.paths,
-      perPage: this.perPage,
-      unlockedAccount: this.unlockedAccount,
-    });
-  }
-
-  deserialize(opts = {}) {
-    this.hdPath = opts.hdPath || hdPathString;
-    this.accounts = opts.accounts || [];
-    this.page = opts.page || 0;
-    this.perPage = opts.perPage || 5;
-    return Promise.resolve();
-  }
-
-  isUnlocked() {
-    return Boolean(this.hdk && this.hdk.publicKey);
-  }
-
-  unlock() {
-    if (this.isUnlocked()) {
-      return Promise.resolve('already unlocked');
-    }
-    return new Promise((resolve, reject) => {
-      TrezorConnect.getPublicKey({
-        path: this.hdPath,
-        coin: 'ETH',
-      })
-        .then((response) => {
-          if (response.success) {
-            this.hdk.publicKey = Buffer.from(response.payload.publicKey, 'hex');
-            this.hdk.chainCode = Buffer.from(response.payload.chainCode, 'hex');
-            resolve('just unlocked');
-          } else {
-            reject(
-              new Error(
-                (response.payload && response.payload.error) || 'Unknown error',
-              ),
-            );
-          }
-        })
-        .catch((e) => {
-          reject(new Error((e && e.toString()) || 'Unknown error'));
-        });
-    });
-  }
-
-  setAccountToUnlock(index) {
-    this.unlockedAccount = parseInt(index, 10);
-  }
-
-  addAccounts(n = 1) {
-    return new Promise((resolve, reject) => {
-      this.unlock()
-        .then((_) => {
-          const from = this.unlockedAccount;
-          const to = from + n;
-
-          for (let i = from; i < to; i++) {
-            const address = this._addressFromIndex(pathBase, i);
-            if (!this.accounts.includes(address)) {
-              this.accounts.push(address);
-            }
-            this.page = 0;
-          }
-          resolve(this.accounts);
-        })
-        .catch((e) => {
-          reject(e);
-        });
-    });
-  }
-
-  getFirstPage() {
-    this.page = 0;
-    return this.__getPage(1);
-  }
-
-  getNextPage() {
-    return this.__getPage(1);
-  }
-
-  getPreviousPage() {
-    return this.__getPage(-1);
-  }
-
-  __getPage(increment) {
-    this.page += increment;
-
-    if (this.page <= 0) {
-      this.page = 1;
-    }
-
-    return new Promise((resolve, reject) => {
-      this.unlock()
-        .then((_) => {
-          const from = (this.page - 1) * this.perPage;
-          const to = from + this.perPage;
-
-          const accounts = [];
-
-          for (let i = from; i < to; i++) {
-            const address = this._addressFromIndex(pathBase, i);
-            accounts.push({
-              address,
-              balance: null,
-              index: i,
-            });
-            this.paths[ethUtil.toChecksumAddress(address)] = i;
-          }
-          resolve(accounts);
-        })
-        .catch((e) => {
-          reject(e);
-        });
-    });
-  }
-
-  getAccounts() {
-    return Promise.resolve(this.accounts.slice());
-  }
-
-  removeAccount(address) {
-    if (
-      !this.accounts.map((a) => a.toLowerCase()).includes(address.toLowerCase())
-    ) {
-      throw new Error(`Address ${address} not found in this keyring`);
-    }
-
-    this.accounts = this.accounts.filter(
-      (a) => a.toLowerCase() !== address.toLowerCase(),
-    );
-  }
-
-  /**
-   * Signs a transaction using Trezor.
-   *
-   * Accepts either an ethereumjs-tx or @ethereumjs/tx transaction, and returns
-   * the same type.
-   *
-   * @template {TypedTransaction | OldEthJsTransaction} Transaction
-   * @param {string} address - Hex string address.
-   * @param {Transaction} tx - Instance of either new-style or old-style ethereumjs transaction.
-   * @returns {Promise<Transaction>} The signed transaction, an instance of either new-style or old-style
-   * ethereumjs transaction.
-   */
-  signTransaction(address, tx) {
-    if (isOldStyleEthereumjsTx(tx)) {
-      // In this version of ethereumjs-tx we must add the chainId in hex format
-      // to the initial v value. The chainId must be included in the serialized
-      // transaction which is only communicated to ethereumjs-tx in this
-      // value. In newer versions the chainId is communicated via the 'Common'
-      // object.
-      return this._signTransaction(address, tx.getChainId(), tx, (payload) => {
-        tx.v = Buffer.from(payload.v, 'hex');
-        tx.r = Buffer.from(payload.r, 'hex');
-        tx.s = Buffer.from(payload.s, 'hex');
-        return tx;
-      });
-    }
-    return this._signTransaction(
-      address,
-      tx.common.chainIdBN().toNumber(),
-      tx,
-      (payload) => {
-        // Because tx will be immutable, first get a plain javascript object that
-        // represents the transaction. Using txData here as it aligns with the
-        // nomenclature of ethereumjs/tx.
-        const txData = tx.toJSON();
-        // The fromTxData utility expects a type to support transactions with a type other than 0
-        txData.type = tx.type;
-        // The fromTxData utility expects v,r and s to be hex prefixed
-        txData.v = ethUtil.addHexPrefix(payload.v);
-        txData.r = ethUtil.addHexPrefix(payload.r);
-        txData.s = ethUtil.addHexPrefix(payload.s);
-        // Adopt the 'common' option from the original transaction and set the
-        // returned object to be frozen if the original is frozen.
-        return TransactionFactory.fromTxData(txData, {
-          common: tx.common,
-          freeze: Object.isFrozen(tx),
-        });
-      },
-    );
-  }
-
-  /**
-   *
-   * @template {TypedTransaction | OldEthJsTransaction} Transaction
-   * @param {string} address - Hex string address.
-   * @param {number} chainId - Chain ID
-   * @param {Transaction} tx - Instance of either new-style or old-style ethereumjs transaction.
-   * @param {(import('trezor-connect').EthereumSignedTx) => Transaction} handleSigning - Converts signed transaction
-   * to the same new-style or old-style ethereumjs-tx.
-   * @returns {Promise<Transaction>} The signed transaction, an instance of either new-style or old-style
-   * ethereumjs transaction.
-   */
-  async _signTransaction(address, chainId, tx, handleSigning) {
-    let transaction;
-    if (isOldStyleEthereumjsTx(tx)) {
-      // legacy transaction from ethereumjs-tx package has no .toJSON() function,
-      // so we need to convert to hex-strings manually manually
-      transaction = {
-        to: this._normalize(tx.to),
-        value: this._normalize(tx.value),
-        data: this._normalize(tx.data),
-        chainId,
-        nonce: this._normalize(tx.nonce),
-        gasLimit: this._normalize(tx.gasLimit),
-        gasPrice: this._normalize(tx.gasPrice),
-      };
-    } else {
-      // new-style transaction from @ethereumjs/tx package
-      // we can just copy tx.toJSON() for everything except chainId, which must be a number
-      transaction = {
-        ...tx.toJSON(),
-        chainId,
-        to: this._normalize(tx.to),
-      };
-    }
-
-    try {
-      const status = await this.unlock();
-      await wait(status === 'just unlocked' ? DELAY_BETWEEN_POPUPS : 0);
-      const response = await TrezorConnect.ethereumSignTransaction({
-        path: this._pathFromAddress(address),
-        transaction,
-      });
-      if (response.success) {
-        const newOrMutatedTx = handleSigning(response.payload);
-
-        const addressSignedWith = ethUtil.toChecksumAddress(
-          ethUtil.addHexPrefix(
-            newOrMutatedTx.getSenderAddress().toString('hex'),
-          ),
-        );
-        const correctAddress = ethUtil.toChecksumAddress(address);
-        if (addressSignedWith !== correctAddress) {
-          throw new Error("signature doesn't match the right address");
-        }
-
-        return newOrMutatedTx;
-      }
-      throw new Error(
-        (response.payload && response.payload.error) || 'Unknown error',
-      );
-    } catch (e) {
-      throw new Error((e && e.toString()) || 'Unknown error');
-    }
-  }
-
-  signMessage(withAccount, data) {
-    return this.signPersonalMessage(withAccount, data);
-  }
-
-  // For personal_sign, we need to prefix the message:
-  signPersonalMessage(withAccount, message) {
-    return new Promise((resolve, reject) => {
-      this.unlock()
-        .then((status) => {
-          setTimeout(
-            (_) => {
-              TrezorConnect.ethereumSignMessage({
-                path: this._pathFromAddress(withAccount),
-                message: ethUtil.stripHexPrefix(message),
-                hex: true,
-              })
-                .then((response) => {
-                  if (response.success) {
-                    if (
-                      response.payload.address !==
-                      ethUtil.toChecksumAddress(withAccount)
-                    ) {
-                      reject(
-                        new Error('signature doesnt match the right address'),
-                      );
-                    }
-                    const signature = `0x${response.payload.signature}`;
-                    resolve(signature);
-                  } else {
-                    reject(
-                      new Error(
-                        (response.payload && response.payload.error) ||
-                          'Unknown error',
-                      ),
-                    );
-                  }
-                })
-                .catch((e) => {
-                  reject(new Error((e && e.toString()) || 'Unknown error'));
-                });
-              // This is necessary to avoid popup collision
-              // between the unlock & sign trezor popups
-            },
-            status === 'just unlocked' ? DELAY_BETWEEN_POPUPS : 0,
-          );
-        })
-        .catch((e) => {
-          reject(new Error((e && e.toString()) || 'Unknown error'));
-        });
-    });
-  }
-
-  /**
-   * EIP-712 Sign Typed Data
-   */
-  async signTypedData(address, data, { version }) {
-    const dataWithHashes = transformTypedData(data, version === 'V4');
-
-    // set default values for signTypedData
-    // Trezor is stricter than @metamask/eth-sig-util in what it accepts
-    const {
-      types: { EIP712Domain = [], ...otherTypes } = {},
-      message = {},
-      domain = {},
-      primaryType,
-      // snake_case since Trezor uses Protobuf naming conventions here
-      domain_separator_hash, // eslint-disable-line camelcase
-      message_hash, // eslint-disable-line camelcase
-    } = dataWithHashes;
-
-    // This is necessary to avoid popup collision
-    // between the unlock & sign trezor popups
-    const status = await this.unlock();
-    await wait(status === 'just unlocked' ? DELAY_BETWEEN_POPUPS : 0);
-
-    const response = await TrezorConnect.ethereumSignTypedData({
-      path: this._pathFromAddress(address),
-      data: {
-        types: { EIP712Domain, ...otherTypes },
-        message,
-        domain,
-        primaryType,
-      },
-      metamask_v4_compat: true,
-      // Trezor 1 only supports blindly signing hashes
-      domain_separator_hash,
-      message_hash,
-    });
-
-    if (response.success) {
-      if (ethUtil.toChecksumAddress(address) !== response.payload.address) {
-        throw new Error('signature doesnt match the right address');
-      }
-      return response.payload.signature;
-    }
-
-    throw new Error(
-      (response.payload && response.payload.error) || 'Unknown error',
-    );
-  }
-
-  exportAccount() {
-    return Promise.reject(new Error('Not supported on this device'));
-  }
-
-  forgetDevice() {
-    this.accounts = [];
-    this.hdk = new HDKey();
-    this.page = 0;
-    this.unlockedAccount = 0;
-    this.paths = {};
-  }
-
-  /**
-   * Set the HD path to be used by the keyring. Only known supported HD paths are allowed.
-   *
-   * If the given HD path is already the current HD path, nothing happens. Otherwise the new HD
-   * path is set, and the wallet state is completely reset.
-   *
-   * @throws {Error] Throws if the HD path is not supported.
-   *
-   * @param {string} hdPath - The HD path to set.
-   */
-  setHdPath(hdPath) {
-    if (!ALLOWED_HD_PATHS[hdPath]) {
-      throw new Error(
-        `The setHdPath method does not support setting HD Path to ${hdPath}`,
-      );
-    }
-
-    // Reset HDKey if the path changes
-    if (this.hdPath !== hdPath) {
-      this.hdk = new HDKey();
-      this.accounts = [];
-      this.page = 0;
-      this.perPage = 5;
-      this.unlockedAccount = 0;
-      this.paths = {};
-    }
-    this.hdPath = hdPath;
-  }
-
-  /* PRIVATE METHODS */
-
-  _normalize(buf) {
-    return ethUtil.bufferToHex(buf).toString();
-  }
-
-  // eslint-disable-next-line no-shadow
-  _addressFromIndex(pathBase, i) {
-    const dkey = this.hdk.derive(`${pathBase}/${i}`);
-    const address = ethUtil
-      .publicToAddress(dkey.publicKey, true)
-      .toString('hex');
-    return ethUtil.toChecksumAddress(`0x${address}`);
-  }
-
-  _pathFromAddress(address) {
-    const checksummedAddress = ethUtil.toChecksumAddress(address);
-    let index = this.paths[checksummedAddress];
-    if (typeof index === 'undefined') {
-      for (let i = 0; i < MAX_INDEX; i++) {
-        if (checksummedAddress === this._addressFromIndex(pathBase, i)) {
-          index = i;
-          break;
-        }
-      }
-    }
-
-    if (typeof index === 'undefined') {
-      throw new Error('Unknown address');
-    }
-    return `${this.hdPath}/${index}`;
-  }
-}
-
-TrezorKeyring.type = keyringType;
-module.exports = TrezorKeyring;
diff --git a/package.json b/package.json
index 88f0450d3a578cdf6be1cd43c7bb2e09cd5a72e8..7610d46d10514902f29e2dcf0e882f05206d65d1 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
-  "name": "eth-trezor-keyring",
-  "version": "0.10.0",
+  "name": "@metamask/eth-trezor-keyring",
+  "version": "1.0.0",
   "description": "A MetaMask compatible keyring, for trezor hardware wallets",
   "keywords": [
     "ethereum",
@@ -19,31 +19,35 @@
   "license": "ISC",
   "author": "Bruno Barbieri",
   "main": "index.js",
+  "types": "types/index.d.ts",
   "files": [
-    "index.js"
+    "index.js",
+    "trezor-keyring.js",
+    "trezor-bridge-web.js",
+    "types/index.d.ts"
   ],
   "scripts": {
-    "setup": "yarn install && yarn allow-scripts",
-    "test": "mocha",
-    "lint:eslint": "eslint . --cache --ext js,ts",
-    "lint:misc": "prettier '**/*.json' '**/*.md' '!CHANGELOG.md' '**/*.yml' --ignore-path .gitignore",
     "lint": "yarn lint:eslint && yarn lint:misc --check",
-    "lint:fix": "yarn lint:eslint --fix && yarn lint:misc --write"
+    "lint:eslint": "eslint . --cache --ext js,ts",
+    "lint:fix": "yarn lint:eslint --fix && yarn lint:misc --write",
+    "lint:misc": "prettier '**/*.json' '**/*.md' '!CHANGELOG.md' '**/*.yml' '!.yarnrc.yml' --ignore-path .gitignore --no-error-on-unmatched-pattern",
+    "test": "mocha"
   },
   "resolutions": {
     "mocha/mkdirp": "^0.5.1"
   },
   "dependencies": {
-    "@ethereumjs/tx": "^3.2.1",
-    "@metamask/eth-sig-util": "^4.0.0",
-    "ethereumjs-util": "^7.0.9",
-    "hdkey": "0.8.0",
-    "trezor-connect": "8.2.6-extended"
+    "@ethereumjs/tx": "^4.0.0",
+    "@ethereumjs/util": "^8.0.0",
+    "@metamask/eth-sig-util": "^5.0.2",
+    "@trezor/connect-plugin-ethereum": "^9.0.1",
+    "@trezor/connect-web": "^9.0.6",
+    "hdkey": "0.8.0"
   },
   "devDependencies": {
-    "@ethereumjs/common": "^2.4.0",
-    "@lavamoat/allow-scripts": "^1.0.6",
-    "@metamask/auto-changelog": "^2.3.0",
+    "@ethereumjs/common": "^3.0.0",
+    "@lavamoat/allow-scripts": "^2.3.0",
+    "@metamask/auto-changelog": "^3.0.0",
     "@metamask/eslint-config": "^8.0.0",
     "@metamask/eslint-config-mocha": "^8.0.0",
     "@metamask/eslint-config-nodejs": "^8.0.0",
@@ -61,8 +65,13 @@
     "prettier-plugin-packagejson": "^2.2.12",
     "sinon": "^9.2.3"
   },
+  "packageManager": "yarn@3.3.1",
   "engines": {
-    "node": ">=12.0.0"
+    "node": ">=14.0.0"
+  },
+  "publishConfig": {
+    "access": "public",
+    "registry": "https://registry.npmjs.org/"
   },
   "lavamoat": {
     "allowScripts": {
@@ -72,7 +81,21 @@
       "core-js": false,
       "blake-hash": false,
       "tiny-secp256k1": false,
-      "protobufjs": false
+      "protobufjs": false,
+      "ethereumjs-tx>ethereumjs-util>keccak": false,
+      "ethereumjs-util>ethereum-cryptography>keccak": false,
+      "ethereumjs-util>ethereum-cryptography>secp256k1": false,
+      "hdkey>secp256k1": false,
+      "trezor-connect>@trezor/transport>protobufjs": false,
+      "trezor-connect>@trezor/utxo-lib>blake-hash": false,
+      "trezor-connect>@trezor/utxo-lib>tiny-secp256k1": false,
+      "@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs": false,
+      "@trezor/connect-web>@trezor/connect>@trezor/utxo-lib>blake-hash": false,
+      "@trezor/connect-web>@trezor/connect>@trezor/utxo-lib>tiny-secp256k1": false,
+      "@ethereumjs/tx>ethereumjs-util>ethereum-cryptography>keccak": false,
+      "@ethereumjs/tx>ethereumjs-util>ethereum-cryptography>secp256k1": false,
+      "ethereumjs-tx>ethereumjs-util>ethereum-cryptography>keccak": false,
+      "ethereumjs-tx>ethereumjs-util>ethereum-cryptography>secp256k1": false
     }
   }
 }
diff --git a/trezor-bridge-web.js b/trezor-bridge-web.js
new file mode 100644
index 0000000000000000000000000000000000000000..d86ad8b2fec28b978ce7d7d77a685261e36e40f5
--- /dev/null
+++ b/trezor-bridge-web.js
@@ -0,0 +1,42 @@
+const { default: TrezorConnect, DEVICE_EVENT } = require('@trezor/connect-web');
+const { TREZOR_CONNECT_MANIFEST } = require('./trezor-keyring');
+
+class TrezorBridgeWeb {
+  init() {
+    TrezorConnect.on(DEVICE_EVENT, (event) => {
+      if (event && event.payload && event.payload.features) {
+        this.model = event.payload.features.model;
+      }
+    });
+
+    return TrezorConnect.init({ manifest: TREZOR_CONNECT_MANIFEST });
+  }
+
+  dispose() {
+    // This removes the Trezor Connect iframe from the DOM
+    // This method is not well documented, but the code it calls can be seen
+    // here: https://github.com/trezor/connect/blob/dec4a56af8a65a6059fb5f63fa3c6690d2c37e00/src/js/iframe/builder.js#L181
+    TrezorConnect.dispose();
+    return Promise.resolve();
+  }
+
+  getPublicKey(params) {
+    return TrezorConnect.getPublicKey(params);
+  }
+
+  ethereumSignTransaction(params) {
+    return TrezorConnect.ethereumSignTransaction(params);
+  }
+
+  ethereumSignMessage(params) {
+    return TrezorConnect.ethereumSignMessage(params);
+  }
+
+  ethereumSignTypedData(params) {
+    return TrezorConnect.ethereumSignTypedData(params);
+  }
+}
+
+module.exports = {
+  TrezorBridgeWeb,
+};
diff --git a/trezor-keyring.js b/trezor-keyring.js
new file mode 100644
index 0000000000000000000000000000000000000000..368667834955d56e749eba725d9b2ca06faa0d84
--- /dev/null
+++ b/trezor-keyring.js
@@ -0,0 +1,534 @@
+const { EventEmitter } = require('events');
+const ethUtil = require('@ethereumjs/util');
+const HDKey = require('hdkey');
+const { TransactionFactory } = require('@ethereumjs/tx');
+const { transformTypedData } = require('@trezor/connect-plugin-ethereum');
+
+const hdPathString = `m/44'/60'/0'/0`;
+const SLIP0044TestnetPath = `m/44'/1'/0'/0`;
+
+const ALLOWED_HD_PATHS = {
+  [hdPathString]: true,
+  [SLIP0044TestnetPath]: true,
+};
+
+const keyringType = 'Trezor Hardware';
+const pathBase = 'm';
+const MAX_INDEX = 1000;
+const DELAY_BETWEEN_POPUPS = 1000;
+const TREZOR_CONNECT_MANIFEST = {
+  email: 'support@metamask.io',
+  appUrl: 'https://metamask.io',
+};
+
+function wait(ms) {
+  return new Promise((resolve) => setTimeout(resolve, ms));
+}
+
+/**
+ * @typedef {import('@ethereumjs/tx').TypedTransaction} TypedTransaction
+ * @typedef {InstanceType<import("ethereumjs-tx")>} OldEthJsTransaction
+ */
+
+/**
+ * Check if the given transaction is made with ethereumjs-tx or @ethereumjs/tx
+ *
+ * Transactions built with older versions of ethereumjs-tx have a
+ * getChainId method that newer versions do not.
+ * Older versions are mutable
+ * while newer versions default to being immutable.
+ * Expected shape and type
+ * of data for v, r and s differ (Buffer (old) vs BN (new)).
+ *
+ * @param {TypedTransaction | OldEthJsTransaction} tx
+ * @returns {tx is OldEthJsTransaction} Returns `true` if tx is an old-style ethereumjs-tx transaction.
+ */
+function isOldStyleEthereumjsTx(tx) {
+  return typeof tx.getChainId === 'function';
+}
+
+class TrezorKeyring extends EventEmitter {
+  constructor({ bridge } = {}) {
+    super();
+    this.type = keyringType;
+    this.accounts = [];
+    this.hdPath = hdPathString;
+    this.hdk = new HDKey();
+    this.page = 0;
+    this.perPage = 5;
+    this.unlockedAccount = 0;
+    this.paths = {};
+
+    if (!bridge) {
+      throw new Error('Bridge is a required dependency for the keyring');
+    }
+
+    this.bridge = bridge;
+  }
+
+  /**
+   * Performs any asynchronous initialisation
+   *
+   * @returns {Promise<void>}
+   */
+  init() {
+    return this.bridge.init();
+  }
+
+  /**
+   * Gets the model, if known.
+   * This may be `undefined` if the model hasn't been loaded yet.
+   *
+   * @returns {"T" | "1" | undefined}
+   */
+  getModel() {
+    return this.bridge.model;
+  }
+
+  /**
+   * Clears the iframe created by Trezor
+   *
+   * @returns {Promise<void>}
+   */
+  dispose() {
+    return this.bridge.dispose();
+  }
+
+  serialize() {
+    return Promise.resolve({
+      hdPath: this.hdPath,
+      accounts: this.accounts,
+      page: this.page,
+      paths: this.paths,
+      perPage: this.perPage,
+      unlockedAccount: this.unlockedAccount,
+    });
+  }
+
+  deserialize(opts = {}) {
+    this.hdPath = opts.hdPath || hdPathString;
+    this.accounts = opts.accounts || [];
+    this.page = opts.page || 0;
+    this.perPage = opts.perPage || 5;
+    return Promise.resolve();
+  }
+
+  isUnlocked() {
+    return Boolean(this.hdk && this.hdk.publicKey);
+  }
+
+  unlock() {
+    if (this.isUnlocked()) {
+      return Promise.resolve('already unlocked');
+    }
+    return new Promise((resolve, reject) => {
+      this.bridge
+        .getPublicKey({
+          path: this.hdPath,
+          coin: 'ETH',
+        })
+        .then((response) => {
+          if (response.success) {
+            this.hdk.publicKey = Buffer.from(response.payload.publicKey, 'hex');
+            this.hdk.chainCode = Buffer.from(response.payload.chainCode, 'hex');
+            resolve('just unlocked');
+          } else {
+            reject(
+              new Error(
+                (response.payload && response.payload.error) || 'Unknown error',
+              ),
+            );
+          }
+        })
+        .catch((e) => {
+          reject(new Error((e && e.toString()) || 'Unknown error'));
+        });
+    });
+  }
+
+  setAccountToUnlock(index) {
+    this.unlockedAccount = parseInt(index, 10);
+  }
+
+  addAccounts(n = 1) {
+    return new Promise((resolve, reject) => {
+      this.unlock()
+        .then((_) => {
+          const from = this.unlockedAccount;
+          const to = from + n;
+
+          for (let i = from; i < to; i++) {
+            const address = this._addressFromIndex(pathBase, i);
+            if (!this.accounts.includes(address)) {
+              this.accounts.push(address);
+            }
+            this.page = 0;
+          }
+          resolve(this.accounts);
+        })
+        .catch((e) => {
+          reject(e);
+        });
+    });
+  }
+
+  getFirstPage() {
+    this.page = 0;
+    return this.__getPage(1);
+  }
+
+  getNextPage() {
+    return this.__getPage(1);
+  }
+
+  getPreviousPage() {
+    return this.__getPage(-1);
+  }
+
+  __getPage(increment) {
+    this.page += increment;
+
+    if (this.page <= 0) {
+      this.page = 1;
+    }
+
+    return new Promise((resolve, reject) => {
+      this.unlock()
+        .then((_) => {
+          const from = (this.page - 1) * this.perPage;
+          const to = from + this.perPage;
+
+          const accounts = [];
+
+          for (let i = from; i < to; i++) {
+            const address = this._addressFromIndex(pathBase, i);
+            accounts.push({
+              address,
+              balance: null,
+              index: i,
+            });
+            this.paths[ethUtil.toChecksumAddress(address)] = i;
+          }
+          resolve(accounts);
+        })
+        .catch((e) => {
+          reject(e);
+        });
+    });
+  }
+
+  getAccounts() {
+    return Promise.resolve(this.accounts.slice());
+  }
+
+  removeAccount(address) {
+    if (
+      !this.accounts.map((a) => a.toLowerCase()).includes(address.toLowerCase())
+    ) {
+      throw new Error(`Address ${address} not found in this keyring`);
+    }
+
+    this.accounts = this.accounts.filter(
+      (a) => a.toLowerCase() !== address.toLowerCase(),
+    );
+  }
+
+  /**
+   * Signs a transaction using Trezor.
+   *
+   * Accepts either an ethereumjs-tx or @ethereumjs/tx transaction, and returns
+   * the same type.
+   *
+   * @template {TypedTransaction | OldEthJsTransaction} Transaction
+   * @param {string} address - Hex string address.
+   * @param {Transaction} tx - Instance of either new-style or old-style ethereumjs transaction.
+   * @returns {Promise<Transaction>} The signed transaction, an instance of either new-style or old-style
+   * ethereumjs transaction.
+   */
+  signTransaction(address, tx) {
+    if (isOldStyleEthereumjsTx(tx)) {
+      // In this version of ethereumjs-tx we must add the chainId in hex format
+      // to the initial v value. The chainId must be included in the serialized
+      // transaction which is only communicated to ethereumjs-tx in this
+      // value. In newer versions the chainId is communicated via the 'Common'
+      // object.
+      return this._signTransaction(address, tx.getChainId(), tx, (payload) => {
+        tx.v = Buffer.from(payload.v, 'hex');
+        tx.r = Buffer.from(payload.r, 'hex');
+        tx.s = Buffer.from(payload.s, 'hex');
+        return tx;
+      });
+    }
+    return this._signTransaction(
+      address,
+      Number(tx.common.chainId()),
+      tx,
+      (payload) => {
+        // Because tx will be immutable, first get a plain javascript object that
+        // represents the transaction. Using txData here as it aligns with the
+        // nomenclature of ethereumjs/tx.
+        const txData = tx.toJSON();
+        // The fromTxData utility expects a type to support transactions with a type other than 0
+        txData.type = tx.type;
+        // The fromTxData utility expects v,r and s to be hex prefixed
+        txData.v = ethUtil.addHexPrefix(payload.v);
+        txData.r = ethUtil.addHexPrefix(payload.r);
+        txData.s = ethUtil.addHexPrefix(payload.s);
+        // Adopt the 'common' option from the original transaction and set the
+        // returned object to be frozen if the original is frozen.
+        return TransactionFactory.fromTxData(txData, {
+          common: tx.common,
+          freeze: Object.isFrozen(tx),
+        });
+      },
+    );
+  }
+
+  /**
+   *
+   * @template {TypedTransaction | OldEthJsTransaction} Transaction
+   * @param {string} address - Hex string address.
+   * @param {number} chainId - Chain ID
+   * @param {Transaction} tx - Instance of either new-style or old-style ethereumjs transaction.
+   * @param {(import('trezor-connect').EthereumSignedTx) => Transaction} handleSigning - Converts signed transaction
+   * to the same new-style or old-style ethereumjs-tx.
+   * @returns {Promise<Transaction>} The signed transaction, an instance of either new-style or old-style
+   * ethereumjs transaction.
+   */
+  async _signTransaction(address, chainId, tx, handleSigning) {
+    let transaction;
+    if (isOldStyleEthereumjsTx(tx)) {
+      // legacy transaction from ethereumjs-tx package has no .toJSON() function,
+      // so we need to convert to hex-strings manually manually
+      transaction = {
+        to: this._normalize(tx.to),
+        value: this._normalize(tx.value),
+        data: this._normalize(tx.data),
+        chainId,
+        nonce: this._normalize(tx.nonce),
+        gasLimit: this._normalize(tx.gasLimit),
+        gasPrice: this._normalize(tx.gasPrice),
+      };
+    } else {
+      // new-style transaction from @ethereumjs/tx package
+      // we can just copy tx.toJSON() for everything except chainId, which must be a number
+      transaction = {
+        ...tx.toJSON(),
+        chainId,
+        to: this._normalize(tx.to),
+      };
+    }
+
+    try {
+      const status = await this.unlock();
+      await wait(status === 'just unlocked' ? DELAY_BETWEEN_POPUPS : 0);
+      const response = await this.bridge.ethereumSignTransaction({
+        path: this._pathFromAddress(address),
+        transaction,
+      });
+      if (response.success) {
+        const newOrMutatedTx = handleSigning(response.payload);
+
+        const addressSignedWith = ethUtil.toChecksumAddress(
+          ethUtil.addHexPrefix(
+            newOrMutatedTx.getSenderAddress().toString('hex'),
+          ),
+        );
+        const correctAddress = ethUtil.toChecksumAddress(address);
+        if (addressSignedWith !== correctAddress) {
+          throw new Error("signature doesn't match the right address");
+        }
+
+        return newOrMutatedTx;
+      }
+      throw new Error(
+        (response.payload && response.payload.error) || 'Unknown error',
+      );
+    } catch (e) {
+      throw new Error((e && e.toString()) || 'Unknown error');
+    }
+  }
+
+  signMessage(withAccount, data) {
+    return this.signPersonalMessage(withAccount, data);
+  }
+
+  // For personal_sign, we need to prefix the message:
+  signPersonalMessage(withAccount, message) {
+    return new Promise((resolve, reject) => {
+      this.unlock()
+        .then((status) => {
+          setTimeout(
+            (_) => {
+              this.bridge
+                .ethereumSignMessage({
+                  path: this._pathFromAddress(withAccount),
+                  message: ethUtil.stripHexPrefix(message),
+                  hex: true,
+                })
+                .then((response) => {
+                  if (response.success) {
+                    if (
+                      response.payload.address !==
+                      ethUtil.toChecksumAddress(withAccount)
+                    ) {
+                      reject(
+                        new Error('signature doesnt match the right address'),
+                      );
+                    }
+                    const signature = `0x${response.payload.signature}`;
+                    resolve(signature);
+                  } else {
+                    reject(
+                      new Error(
+                        (response.payload && response.payload.error) ||
+                          'Unknown error',
+                      ),
+                    );
+                  }
+                })
+                .catch((e) => {
+                  reject(new Error((e && e.toString()) || 'Unknown error'));
+                });
+              // This is necessary to avoid popup collision
+              // between the unlock & sign trezor popups
+            },
+            status === 'just unlocked' ? DELAY_BETWEEN_POPUPS : 0,
+          );
+        })
+        .catch((e) => {
+          reject(new Error((e && e.toString()) || 'Unknown error'));
+        });
+    });
+  }
+
+  /**
+   * EIP-712 Sign Typed Data
+   */
+  async signTypedData(address, data, { version }) {
+    const dataWithHashes = transformTypedData(data, version === 'V4');
+
+    // set default values for signTypedData
+    // Trezor is stricter than @metamask/eth-sig-util in what it accepts
+    const {
+      types: { EIP712Domain = [], ...otherTypes } = {},
+      message = {},
+      domain = {},
+      primaryType,
+      // snake_case since Trezor uses Protobuf naming conventions here
+      domain_separator_hash, // eslint-disable-line camelcase
+      message_hash, // eslint-disable-line camelcase
+    } = dataWithHashes;
+
+    // This is necessary to avoid popup collision
+    // between the unlock & sign trezor popups
+    const status = await this.unlock();
+    await wait(status === 'just unlocked' ? DELAY_BETWEEN_POPUPS : 0);
+
+    const response = await this.bridge.ethereumSignTypedData({
+      path: this._pathFromAddress(address),
+      data: {
+        types: { EIP712Domain, ...otherTypes },
+        message,
+        domain,
+        primaryType,
+      },
+      metamask_v4_compat: true,
+      // Trezor 1 only supports blindly signing hashes
+      domain_separator_hash,
+      message_hash,
+    });
+
+    if (response.success) {
+      if (ethUtil.toChecksumAddress(address) !== response.payload.address) {
+        throw new Error('signature doesnt match the right address');
+      }
+      return response.payload.signature;
+    }
+
+    throw new Error(
+      (response.payload && response.payload.error) || 'Unknown error',
+    );
+  }
+
+  exportAccount() {
+    return Promise.reject(new Error('Not supported on this device'));
+  }
+
+  forgetDevice() {
+    this.accounts = [];
+    this.hdk = new HDKey();
+    this.page = 0;
+    this.unlockedAccount = 0;
+    this.paths = {};
+  }
+
+  /**
+   * Set the HD path to be used by the keyring. Only known supported HD paths are allowed.
+   *
+   * If the given HD path is already the current HD path, nothing happens. Otherwise the new HD
+   * path is set, and the wallet state is completely reset.
+   *
+   * @throws {Error] Throws if the HD path is not supported.
+   *
+   * @param {string} hdPath - The HD path to set.
+   */
+  setHdPath(hdPath) {
+    if (!ALLOWED_HD_PATHS[hdPath]) {
+      throw new Error(
+        `The setHdPath method does not support setting HD Path to ${hdPath}`,
+      );
+    }
+
+    // Reset HDKey if the path changes
+    if (this.hdPath !== hdPath) {
+      this.hdk = new HDKey();
+      this.accounts = [];
+      this.page = 0;
+      this.perPage = 5;
+      this.unlockedAccount = 0;
+      this.paths = {};
+    }
+    this.hdPath = hdPath;
+  }
+
+  /* PRIVATE METHODS */
+
+  _normalize(buf) {
+    return ethUtil.bufferToHex(buf).toString();
+  }
+
+  // eslint-disable-next-line no-shadow
+  _addressFromIndex(pathBase, i) {
+    const dkey = this.hdk.derive(`${pathBase}/${i}`);
+    const address = ethUtil
+      .publicToAddress(dkey.publicKey, true)
+      .toString('hex');
+    return ethUtil.toChecksumAddress(`0x${address}`);
+  }
+
+  _pathFromAddress(address) {
+    const checksummedAddress = ethUtil.toChecksumAddress(address);
+    let index = this.paths[checksummedAddress];
+    if (typeof index === 'undefined') {
+      for (let i = 0; i < MAX_INDEX; i++) {
+        if (checksummedAddress === this._addressFromIndex(pathBase, i)) {
+          index = i;
+          break;
+        }
+      }
+    }
+
+    if (typeof index === 'undefined') {
+      throw new Error('Unknown address');
+    }
+    return `${this.hdPath}/${index}`;
+  }
+}
+
+TrezorKeyring.type = keyringType;
+
+module.exports = {
+  TREZOR_CONNECT_MANIFEST,
+  TrezorKeyring,
+};
diff --git a/types/index.d.ts b/types/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6890e807c30ff2ce76b26075c6b581e7207001a2
--- /dev/null
+++ b/types/index.d.ts
@@ -0,0 +1,31 @@
+import type {
+  TrezorConnect,
+  EthereumSignMessage,
+  EthereumSignTransaction,
+  Params,
+  EthereumSignTypedData,
+  EthereumSignTypedDataTypes,
+  GetPublicKey,
+} from '@trezor/connect-web';
+
+export interface TrezorBridge {
+  init(): Promise<void>;
+
+  dispose(): Promise<void>;
+
+  getPublicKey(
+    params: Params<GetPublicKey>,
+  ): ReturnType<TrezorConnect['getPublicKey']>;
+
+  ethereumSignTransaction(
+    params: Params<EthereumSignTransaction>,
+  ): ReturnType<TrezorConnect['ethereumSignTransaction']>;
+
+  ethereumSignMessage(
+    params: Params<EthereumSignMessage>,
+  ): ReturnType<TrezorConnect['ethereumSignMessage']>;
+
+  ethereumSignTypedData(
+    params: Params<EthereumSignTypedData<EthereumSignTypedDataTypes>>,
+  ): ReturnType<TrezorConnect['ethereumSignTypedData']>;
+}
